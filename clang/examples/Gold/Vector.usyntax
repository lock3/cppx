
<# Defining implicit utility function, macros, and builtins.  #>;
std = namespace:
  __throw_bad_alloc()<noreturn><extern>:void

__STDCPP_DEFAULT_NEW_ALIGNMENT__<constexpr>:int = 8

addressof[T:type](x:ref T)<inline>:^T !
  return __builtin_addressof(x)

<# Defining Remove reference for perfect forwarding. #>;
remove_reference[T:type] = class { ty : type = T; }
remove_reference[T:type][ref T] = class { ty : type = T; }
remove_reference[T:type][rref T] = class { ty : type = T; }

<# Defining forwarding function. #>;
forward[T:type](t:ref remove_reference[T].ty)<constexpr>:rref T !{
  return static_cast[rref T](t);
}

forward[T:type](t:rref remove_reference[T].ty)<constexpr>:rref T !{
  return static_cast[rref remove_reference[T].ty](t);
}

move[T:type](t:rref T)<noexcept><constexpr>:rref remove_reference[T].ty! {
  return static_cast[rref remove_reference[T].ty](t);
}

<# This needs overload/enable_if for memcpy overload. #>;
fill[FwdIt:type, T:type](s:FwdIt, e:FwdIt, val:ref const T):void! {
  while(s <> e) {
    ^s = val
    s += 1;
  }
}

<# This needs overload/enable_if for memcpy overload. #>;
fill_n[FwdIt:type, T:type](s:FwdIt, n:uint64, val:ref const T):FwdIt! {
  for(x in 0..(n-1)) {
    ^s = val
    s += 1;
  }
  return s;
}

<# This needs overload/enable_if for memcpy overload. #>;
uninitialized_fill[FwdIt:type, T:type](s:FwdIt, e:FwdIt, val:ref const T):FwdIt! {
  while(s <> e) {
    s.construct(val);
    s += 1;
  }
  return s;
}

<# This needs overload/enable_if for memcpy overload. #>;
uninitialized_fill_n[FwdIt:type, T:type](s:FwdIt, n:uint64, val:ref const T):FwdIt! {
  for(x in 0..(n-1)) {
    s.construct(val);
    s += 1;
  }
  return s;
}

uninitialized_default_n[InputIt:type](s:InputIt, n:uint64) :InputIt! {
  for(x in 0..(n-1)) {
    s.construct();
    s += 1;
  }
  return s;
}

<# This needs overload/enable_if for trivially distructable types #>;
destroy_range[FwdIt:type](s:FwdIt, e:FwdIt)<noexcept>: void! {
  while(s <> e) {
    s.destruct();
    s += 1;
  }
}

uninitialized_move[InputIt:type, FwdIt:type](s:InputIt, e:InputIt, out:FwdIt) : FwdIt! {
  while(s <> e) {
    out.construct(move(^s));
    s += 1;
    out += 1;
  }
  return out;
}

move_backwards[BiDirIt1:type, BiDirIt2:type](first:BiDirIt1, last:BiDirIt1,
                                             out:BiDirIt2): BiDirIt2! {
  while(first <> last) {
    out -= 1;
    last -= 1;
    ^out = move(^last);
  }
  return out;
}


max[T:type] (x:ref const T, y:ref const T) : T! {
  if (x > y):
    return x;
  return y;
}

copy[InputIt:type, OutputIt:type](s:InputIt, e:InputIt, out:OutputIt):OutputIt! {
  while (s <> e) {
    ^out = ^s;
    out += 1;
    s += 1;
  }
  return out;
}

exception = class {
  constructor() = default;
  what()<virtual><const><noexcept> : ^ const char = 0;
}

logic_error = class(exception) {
  constructor() = default;
  constructor(m: ^ const char)! { this.init(m); }
  constructor(other: ref const logic_error) = default;
  constructor(other: rref logic_error) = default;
  operator"="(other: ref const logic_error) : ref logic_error = default;
  operator"="(other: rref logic_error) : ref logic_error = default;

  init(m : ^ const char):void! {
    this.msg = m;
  }

  what()<override><const><noexcept> : ^ const char! {
    return this.msg;
  }
  msg<private>: ^ const char = null;
}

length_error = class(logic_error) {
  constructor() = default;
  constructor(msg: ^ const char)! {
    static_cast[^logic_error](this).init(msg);
  }
  constructor(other: ref const length_error) = default;
  constructor(other: rref length_error) = default;
  operator"="(other: ref const length_error) : ref length_error = default;
  operator"="(other: rref length_error) : ref length_error = default;
}

out_of_range = class(logic_error) {
  constructor() = default;
  constructor(msg: ^ const char)! {
    static_cast[^logic_error](this).init(msg);
  }
  constructor(other: ref const out_of_range) = default;
  constructor(other: rref out_of_range) = default;
  operator"="(other: ref const out_of_range) : ref out_of_range = default;
  operator"="(other: rref out_of_range) : ref out_of_range = default;
}

swap[T:type](x:ref T, y:ref T):void! {
  temp = x;
  x = y;
  y = temp;
}

<# Defining the new_allocator #>;
new_allocator[T:type] : type = class{


  size_type : type = uint64
  difference_type : type = int64
  pointer : type = ^T
  const_pointer : type = ^ const T
  reference : type = ref T
  const_reference : type = ref const T

  rebind[T1:type] : type = class { other : type = new_allocator[T1]; }

  constructor()<noexcept>! { }
  constructor(other:ref const new_allocator[T])<noexcept>! { }
  constructor[T1:type](other:ref const new_allocator[T1])<noexcept>! { }
  destructor()<noexcept>! { }

  init()<noexcept>:void !{ }
  init[T1:type](other:ref const new_allocator[T1])<noexcept>:void !{ }
  init(other:ref const new_allocator[T])<noexcept>:void !{ }

  address(x : reference)<const><noexcept>:pointer! {
    return addressof(x);
  }

  address(x : const_reference)<const><noexcept>:const_pointer! {
    return addressof(x);
  }

  <# Alignment has been removed because we don't support it for implicit operator new functions. #>;
  allocate(n:size_type, ignored:^const void = null): pointer !{
    if (n > this.max_size()) {
      std.__throw_bad_alloc();
    }
    return static_cast[^T](operator"new"(n*sizeof(T)));
  }

  deallocate(p:pointer, s:size_type) : void! {
    operator"delete"(p);
  }

  max_size()<const><noexcept>:size_type! {
    return size_type(-1) / sizeof(T);
  }

  do_construct[Up:type, A:type...](p: ^Up, args:rref A...) : void !{
    p.construct(forward[A](args)...);
  }

  destroy[Up:type](p: ^Up) : void !{
    Up.destruct();
  }
}

operator"=="[T:type](x:ref const new_allocator[T], y:ref const new_allocator[T])<inline>:bool! {
  return true;
}

operator"<>"[T:type](x:ref const new_allocator[T], y:ref const new_allocator[T])<inline>:bool! {
  return false;
}

VectorBase[T:type, Alloc:type] : type = class{

  T_alloc_type : type = Alloc.rebind[T].other
  pointer : type = T_alloc_type.pointer
  size_type : type = uint64

  VectorImpl : type = class(T_alloc_type) {
    start:pointer;
    finish:pointer;
    storage_end:pointer;

    constructor()! {
      this.init();
    }

    init():void !{
      static_cast[^T_alloc_type](this).init();
      this.start = null;
      this.finish = null;
      this.storage_end = null;
    }

    constructor(a:ref const allocator_type)! {
      this.init(a);
    }

    init(a:ref const allocator_type):void !{
      static_cast[^T_alloc_type](this).init(a);
      this.start = null;
      this.finish = null;
      this.storage_end = null;
    }

    init(other:rref VectorImpl):void! {
      this.start = other.start;
      this.finish = other.finish;
      this.storage_end = other.storage_end;
      static_cast[^T_alloc_type](this).init(move(static_cast[rref allocator_type](other)));
      other.start = null;
      other.finish = null;
      other.storage_end = null;
    }


    member_swap(other:ref VectorImpl):void! {
      swap(this.start, other.start);
      swap(this.finish, other.finish);
      swap(this.storage_end, other.storage_end);
    }
  }

  allocator_type : type = Alloc

  get_T_allocator()<noexcept>:ref T_alloc_type !{
    return ^static_cast[^T_alloc_type](&this.impl);
  }

  get_T_allocator()<const><noexcept>:ref const T_alloc_type !{
    return ^static_cast[^ const T_alloc_type](&this.impl);
  }

  impl:VectorImpl;

  get_allocator()<const><noexcept>:allocator_type! {
    return allocator_type(get_T_allocator());
  }

  init():void!{
    this.impl.init();
  }

  init(a:ref const allocator_type)<noexcept> : void!{
    this.impl.init(a);
  }

  init(n:size_type):void!{
    this.impl.init();
    this.create_storage(n);
  }

  init(n:size_type, a:ref const allocator_type):void! {
    this.impl.init(a);
    this.create_storage(n);
  }

  init(a:rref allocator_type):void! {
    this.impl.init(a);
  }

  init(x:rref VectorBase[T, Alloc]):void! {
    this.impl.init(move(x.get_T_allocator()));
    this.impl.member_swap(x.impl);
  }

  init(x:rref VectorBase[T, Alloc], a:ref const allocator_type) : void! {
    this.impl.init(move(a));
    if (x.get_allocator() == a) {
      this.impl.member_swap(x.impl);
    } else {
      n: size_type = x.impl.finish- x.impl.start;
      this.create_storage(n);
    }
  }

  destructor()<noexcept>! {
    this.do_deallocate(this.impl.start, this.impl.storage_end - this.impl.start);
  }

  do_allocate(n:size_type):pointer!{
    if (n==0) {
      return null;
    }
    return this.impl.allocate(n);
  }

  do_deallocate(p:pointer, n:size_type):void! {
    this.impl.deallocate(p, n);
  }

  create_storage(n:size_type)<private>:void!{
    this.impl.start = this.do_allocate(n);
    this.impl.finish = this.impl.start;
    this.impl.storage_end = this.impl.start + n;
  }
}

vector[T:type, Alloc:type = new_allocator[T]]:type = class(VectorBase[T, Alloc]<protected>){

  base<private> : type = VectorBase[T, Alloc];
  T_alloc_type<private> : type = VectorBase[T, Alloc].T_alloc_type;

  <# Usual type defs#>;

  value_type : type = T;
  size_type : type = T_alloc_type.size_type;
  difference_type : type = T_alloc_type.difference_type;
  pointer : type = T_alloc_type.pointer;
  const_pointer : type = T_alloc_type.const_pointer;
  reference : type = T_alloc_type.reference;
  const_reference : type = T_alloc_type.const_reference;
  allocator_type : type = Alloc;

  iterator : type = pointer;
  const_iterator : type = const_pointer;

  using { base.do_allocate, base.do_deallocate, base.impl, base.get_T_allocator };

  default_initialize(n:size_type)<private> : void! {
    it:auto = this.impl.start;
    for(x in 0..(n-1)) {
      it.construct();
      it += 1;
    }
    this.impl.finish = it;
  }

  fill_initialize(n:size_type, val:ref const value_type)<private>:void! {
    it:auto = this.impl.start;
    for(x in 0..(n-1)) {
      it.construct(val);
      it += 1;
    }
    this.impl.finish = it;
  }

  fill_assign(n:size_type, val:ref const value_type)<private>:void! {
    if (n > this.capacity()) {
      temp:vector[T, Alloc] = vector[T, Alloc](n, val, this.get_T_allocator());
      temp.impl.member_swap(this.impl);
    } else if (n > this.size()) {
      fill(begin(), end(), val);
      this.impl.finish = uninitialized_fill_n(this.impl.finish, n - size(), val);
    } else {
      this.erase_at_end(fill_n(this.impl.start, n, val));
    }
  }

  erase_at_end(pos:pointer)<private><noexcept>:void! {
    destroy_range(pos, this.impl.finish);
    this.impl.finish = pos;
  }

  copy_range_init[Iter:type](s:Iter, e:Iter)<private>:void! {
    while(s <> e) {
      this.emplace_back(^s);
      s += 1;
    }
  }

  default_append(n:size_type)<private>:void! {
    if (n <> 0) {
      if (size_type(this.impl.storage_end - this.impl.finish) >= n) {
        this.impl.finish = uninitialized_default_n(this.impl.finish, n);
      } else {
        for(x in 0..(n-1)) {
          this.emplace_back();
        }
      }
    }
  }

  check_len(n:size_type, owner:^const char)<const><private>:size_type! {
    if ((this.max_size() - this.size()) < n) {
      throw length_error(owner);
    }
    len:const size_type = this.size() + max(this.size(), n);
    if ((len < this.size()) || len > this.max_size()) {
      return this.max_size()
    }
    return len;
  }

  fill_insert(pos:iterator, n:size_type, val:ref const value_type)<private>:void! {
    if (n <> 0) {
      if (size_type(this.impl.storage_end - this.impl.finish) >=n) {
        temp_cpy:value_type = val;
        elements_after = end() - pos;
        old_finish:pointer = this.impl.finish;
        if (elements_after > n) {
          uninitialized_move(this.impl.finish - n, this.impl.finish,
                             this.impl.finish);
          move_backwards(pos, old_finish - n, old_finish);
          fill(pos, pos + n, temp_cpy);
        } else {
          this.impl.finish = uninitialized_fill_n(this.impl.finish,
                                                  n - elements_after,
                                                  temp_cpy);
          uninitialized_move(pos, old_finish, this.impl.finish);
          this.impl.finish += elements_after;
          fill(pos, old_finish, temp_cpy);
        }
      } else {
        len:const uint64 = this.check_len(n, "vector::fill_insert");

        elems_before:size_type = pos - begin();
        new_start:pointer = this.do_allocate(len);
        new_finish : pointer = new_start;
        _ {
          uninitialized_fill_n(new_start +elems_before, n, val);
          new_finish = pointer();
          new_finish = uninitialized_move(this.impl.start, pos, new_start);
          new_finish += n;
          new_finish = uninitialized_move(pos, this.impl.finish, new_finish);
        } catch() {
          if (!new_finish) {
            destroy_range(new_start + elems_before, new_start + elems_before + n);
          } else {
            destroy_range(new_start + elems_before, new_finish);
          }
          this.do_deallocate(new_start, len);
          throw;
        }
        destroy_range(this.impl.start, this.impl.finish);
        this.do_deallocate(this.impl.start,
                           this.impl.storage_end - this.impl.start);
        this.impl.start = new_start;
        this.impl.finish = new_finish;
        this.impl.storage_end = new_start + len;
      }
    }
  }

  allocate_and_move[FwdIt:type](n:size_type, s:FwdIt, e:FwdIt)<private> : pointer! {
    result:pointer = this.do_allocate(n);
    _{
      uninitialized_move(s, e, result);
      return result;
    } catch() {
      this.do_deallocate(result, n);
      throw;
    }
  }

  <# Constructor and assign() #>;
  constructor()! {
    this.impl.init();
  }

  constructor(a:ref const allocator_type)<explicit><noexcept>! {
    this.impl.init(a);
  }

  constructor(n:size_type, a:ref const allocator_type = allocator_type())! {
    this.(base)init(n, a);
    default_initialize(n);
  }

  constructor(n:size_type, v:ref const value_type,
              a:ref const allocator_type = allocator_type())! {
    this.(base)init(n, a);
    fill_initialize(n, v);
  }

  constructor(other:ref const vector[T, Alloc]):void! {
    this.(base)init(other.size(), other.get_allocator());
    otherIt = other.begin();
    it:auto = this.impl.start;
    while(otherIt <> other.end()):
      it.construct(^otherIt);
      it += 1;
      otherIt += 1;
    this.impl.finish = it;
  }

  constructor(other:rref vector[T, Alloc])! {
    this.(base)init(move(other));
  }

  <# Intentionally missing the move constructor with supplied allocator #>;
  <# Missing initializer list constructor because we don't support that yet. #>;

  constructor[It:type](s:It, e:It)! {
    this.impl.init();
    this.copy_range_init(s, e);
  }

  destructor() ! {
    it:auto = this.impl.start;
    while(it <> this.impl.finish) {
      it.destruct();
      it +=1;
    }
  }

  size()<const>:size_type! {
    return size_type(this.impl.finish - this.impl.start);
  }

  max_size()<const>:size_type! {
    return size_type(this.impl.max_size());
  }

  clear():void! {
    it:auto = this.impl.start;
    while(it <> this.impl.finish) {
      it.destruct();
      it += 1;
    }
    this.impl.finish = this.impl.start;
  }

  operator"="(other:ref const vector[T, Alloc]): ref vector[T, Alloc]! {
    this.clear();
    otherIt = other.begin();
    while( otherIt <> other.end()):
      this.emplace_back(^otherIt);
      otherIt += 1;
    return ^this
  }

  operator"="(other:rref vector[T, Alloc]): ref vector[T, Alloc]! {
    this.clear();
    if (this.get_allocator() == other.get_allocator()) {
      this.impl.member_swap(other.impl);
    } else {
      otherIt = other.begin();
      for(x in 0..(other.size() - 1)):
        this.emplace_back(move(^otherIt));
        otherIt += 1;
    }
    return ^this
  }

  <# Missing initializer list assignment because we don't support that yet. #>;
  assign(n:size_type, val:ref const value_type): void! {
    fill_assign(n, val);
  }

  assign[FwdIt:type](s:FwdIt, e:FwdIt):void! {
    this.clear();
    while(s <> e) {
      this.emplace_back(^s);
      s += 1;
    }
  }

  using { base.get_allocator };

  begin()<noexcept>:iterator !{ return iterator(this.impl.start); }
  begin()<const><noexcept>:const_iterator !{ return const_iterator(this.impl.start); }
  end()<noexcept>:iterator !{ return iterator(this.impl.finish); }
  end()<const><noexcept>:const_iterator !{ return const_iterator(this.impl.finish); }

  <# Reverse iterators not implemented yet. #>;


  cbegin()<const><noexcept>:const_iterator! { return const_iterator(this.impl.start); }
  cend()<const><noexcept>:const_iterator! { return const_iterator(this.impl.finish); }


  resize(n:size_type):void! {
    if (n > this.size()) {
      this.default_append(n - this.size());
    } else if (n < this.size()) {
      this.erase_at_end(this.impl.start + n)
    }
  }

  resize(n:size_type, val:ref const value_type):void! {
    if (n > this.size()) {
      this.fill_insert(end(), n-size(), val);
    } else if (n < this.size()) {
      this.erase_at_end(this.impl.start + n)
    }
  }

  shrink_to_fit():void! {
    if (this.capacity() <> this.size()) {
      new_start:pointer = this.do_allocate(this.size());
      new_finish = uninitialized_move(begin(), end(), new_start);
      this.do_deallocate(this.impl.start, size());
      this.impl.start = new_start;
      this.impl.finish = new_finish;
      this.impl.storage_end = this.impl.finish;
    }
  }

  capacity()<const><noexcept> : size_type! {
    return size_type(this.impl.storage_end- this.impl.start);
  }

  empty()<const><noexcept> : bool! {
    return begin() == end();
  }

  reserve(n:size_type):void! {
    if (n> this.max_size()) {
      throw length_error("vector::reserve");
    }
    if (this.capacity() < n) {
      old_size:const size_type = this.size();
      temp_ptr:pointer = this.allocate_and_move(n, this.impl.start, this.impl.finish);
      destroy_range(this.impl.start, this.impl.finish);
      this.do_deallocate(this.impl.start, this.impl.storage_end - this.impl.start);
      this.impl.start = temp_ptr;
      this.impl.finish = temp_ptr + old_size;
      this.impl.storage_end = this.impl.start + n;
    }
  }

  operator"[]"(n:size_type)<noexcept>:reference! {
    return ^(this.impl.start + n);
  }

  operator"[]"(n:size_type)<const><noexcept>:const_reference! {
    return ^(this.impl.start + n);
  }

  check_range(n:size_type)<const><protected>:void! {
    if (n>this.size()){
      throw out_of_range("attrange violation");
    }
  }

  at(n:size_type):reference! {
    this.check_range(n);
    return (^this)[n];
  }

  at(n:size_type)<const>:const_reference! {
    this.check_range(n);
    return (^this)[n];
  }

  front()<noexcept>:reference! {
    return ^begin();
  }

  front()<noexcept><const>:const_reference! {
    return ^begin();
  }

  back()<noexcept>:reference! {
    return ^(end()-1);
  }

  back()<noexcept><const>:const_reference! {
    return ^(end()-1);
  }

  data()<noexcept>:pointer! {
    return this.impl.start;
  }

  data()<const><noexcept>:const_pointer! {
    return this.impl.start;
  }

  realloc_insert[Args:type...](position:iterator, arguments:rref Args...) <protected>:void !{
    one = size_type(1)
    len:const size_type = this.check_len(one, "vector::realloc_insert");
    elems_before:const size_type = position - this.begin();
    new_start:pointer = this.do_allocate(len);
    new_finish:pointer = new_start;
    _{
      temp = ((new_start + elems_before))
      temp.construct(forward[Args](arguments)...);
      new_finish = pointer();
      new_finish = uninitialized_move(this.impl.start, position, new_start)
      new_finish += 1;
      new_finish = uninitialized_move(position, this.impl.finish, new_finish);
    } catch() {
      if (!new_finish) {
        ((new_start + elems_before)).destruct();
      } else {
        destroy_range(new_start, new_finish);
      }
      throw;
    }
    destroy_range(this.impl.start, this.impl.finish);
    this.do_deallocate(this.impl.start, this.impl.storage_end - this.impl.start);
    this.impl.start = new_start;
    this.impl.finish = new_finish;
    this.impl.storage_end = new_start + len;
  }

  push_back(x:ref const value_type):void! {
    if (this.impl.finish <> this.impl.storage_end) {
      this.impl.finish.construct(x);
      this.impl.finish += 1;
    } else {
      this.realloc_insert(end(), x);
    }
  }

  push_back(x:rref value_type):void! {
    this.emplace_back(move(x));
  }

  emplace_back[Args:type...](arguments:rref Args...):reference ! {
    if (this.impl.finish <> this.impl.storage_end && this.impl.finish <> null) {
      this.impl.finish.construct(forward[Args](arguments)...);
      this.impl.finish += 1;
    } else {
      this.realloc_insert(end(), forward[Args](arguments)...);
    }
    return this.back();
  }

  pop_back():void! {
    this.impl.finish.destruct();
    this.impl.finish -= 1;
  }

  insert_aux[Arg:type](position:iterator, arg:rref Arg):void! {
    this.impl.finish.construct(move(^(this.impl.finish - 1)));
    this.impl.finish += 1;
    move_backwards(position, this.impl.finish - 2, this.impl.finish - 1);
    ^position = forward[Arg](arg);
  }

  emplace_aux[Arg:type](position:iterator, arg:rref Arg)<protected>:iterator! {
    this.impl.finish.construct(move(^(this.impl.finish - 1)));
    this.impl.finish += 1;
    move_backwards(position, this.impl.finish - 2, this.impl.finish - 1);
    ^position = forward[Arg](arg);
  }

  emplace_aux[Args:type...](position:const_iterator, arguments:rref Args...)<protected>:iterator ! {
    n:auto = position - cbegin();
    if (this.impl.finish <> this.impl.storage_end) {
      if (position == cend()) {
        this.impl.finish.construct(forward[Args](arguments)...);
        this.impl.finish += 1;
      } else {
        this.insert_aux(begin() + n, move(T(forward[Args](arguments)...)));
      }
    } else {
      this.realloc_insert(begin() + n, forward[Args](arguments)...);
    }
    return begin() + n;
  }

  emplace[Args:type...](position:const_iterator, arguments:rref Args...) : iterator! {
    return this.emplace_aux(position, forward[Args](arguments)...);
  }

  insert(position:const_iterator, x:ref const value_type):iterator !{
    n:size_type = position - begin();
    if (this.impl.finish <> this.impl.storage_end) {
      if (position == this.end()) {
        this.impl.finish.construct(x);
        this.impl.finish += 1;
      } else {
        new_position:auto = this.begin() + (position - this.cbegin());
        this.insert_aux(new_position, x)
      }
    } else {
      this.realloc_insert(this.begin() + (position - this.cbegin()), x);
    }
    return iterator(this.impl.start + n);
  }

  insert_rval(position:const_iterator, x:rref value_type)<protected>:iterator! {
    n:size_type = position - this.cbegin();
    if (this.impl.finish <> this.impl.storage_end) {
      if (position == this.end()) {
        this.impl.finish.construct(move(x));
        this.impl.finish += 1;
      } else {
        new_position:auto = this.begin() + (position - this.cbegin());
        this.insert_aux(new_position, move(x))
      }
    } else {
      this.realloc_insert(this.begin() + (position - this.cbegin()), move(x));
    }
    return iterator(this.impl.start + n);
  }

  insert(position:const_iterator, x:rref value_type):iterator!{
    return this.insert_rval(position, move(x));
  }

  insert(position:const_iterator, n:size_type, x:ref const value_type):iterator!{
    offset:auto = position -this.cbegin();
    fill_insert(begin() + offset, n, x);
    return begin() + offset;
  }

  insert[InputIt:type](position:const_iterator, first:InputIt, last:InputIt):iterator! {
    offset:auto = position - begin();
    insPos:iterator = begin() + offset;
    while(first <> last) {
      insPos = insert(insPos, ^first);
      insPos += 1;
      first += 1;
    }
    return begin() + offset;
  }

  erase(position:iterator):void! {
    if (position <> this.end()) {
      this.impl.finish = copy(position + 1, this.end(), position);
    }
  }

  erase(first:iterator, last:iterator):void! {
    if (first <> last){
      this.erase_at_end(copy(last, this.end(), first));
    }
  }


  swap(other:ref vector[T, Alloc])<noexcept>:void! {
    this.impl.member_swap(other.impl);
  }

  dumpContents() : void!
    print("  Size = %ull\n", this.size());
    print("  Start %p\n", this.impl.start);
    print("  finish %p\n", this.impl.finish);
    print("  storage end %p\n", this.impl.storage_end);
    print("  Capacity: %ull\n", this.capacity());
    print("  max size: %ull\n", this.max_size())
}

cchar_ptr:type = ^const cchar;

print(msg:^ const char, varargs : args) :int! {
  vlist : __builtin_va_list;
  c_msg_ptr:cchar_ptr = reinterpret_cast[cchar_ptr](msg);
  __builtin_va_start(vlist, c_msg_ptr);
  done:int = 0;
  done = __builtin___vprintf_chk(0, c_msg_ptr, vlist);
  __builtin_va_end(vlist);
  return done;
}

test_failure = class(exception) {

  constructor() = default;
  constructor(m: ^ const char)! { this.init(m); }
  constructor(other: ref const test_failure) = default;
  constructor(other: rref test_failure) = default;
  operator"="(other: ref const test_failure) : ref test_failure = default;
  operator"="(other: rref test_failure) : ref test_failure = default;

  init(m : ^ const char):void! {
    this.msg = m;
  }

  what()<override><const><noexcept> : ^ const char! {
    return this.msg;
  }
  msg<private>: ^ const char = null;
}

test_name:^ const char = null;

passed_test_count: int = 0;
failed_test_count: int = 0;

print_cur_test_name():void! {
  if (test_name) {
    print(test_name);
    print("\n");
  }
}
test_true(codeStr:^const char, result:bool):void! {
  if (!result) {
    failed_test_count += 1;
    print_cur_test_name();
    print("Test failure for code: ");
    print(codeStr);
    print("\n");
  } else {
    passed_test_count += 1;
  }
}


main():int !{
  test_name = "Default ConstructorTest";
  {
    subject:vector[int];
    test_true("subject.size() == 0", subject.size() == 0);
    test_true("subject.capacity() == 0", subject.capacity() == 0);
  }

  test_name = "Push back";
  {
    subject:vector[int];
    subject.push_back(4);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject.capacity() <> 0", subject.capacity() <> 0);
    test_true("subject[0] == 4", subject[0] == 4);
  }


  test_name = "clear";
  {
    subject:vector[int];
    subject.push_back(4);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject.capacity() <> 0", subject.capacity() <> 0);
    test_true("subject[0] == 4", subject[0] == 4);
    subject.clear();
    test_true("subject.size() == 0", subject.size() == 0);
    test_true("subject.capacity() <> 0", subject.capacity() <> 0);
  }

  test_name = "copy assignment";
  {
    subject:vector[int];
    subject.push_back(4);
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)

    test_true("subject2.size() == 10", subject2.size() == 10);
    test_true("subject.size() == 1", subject.size() == 1);
    subject = subject2;
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject2.size() == 10", subject2.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
    # Making sure the original is still the same.
    test_true("subject2[0] == 0", subject2[0] == 0);
    test_true("subject2[1] == 1", subject2[1] == 1);
    test_true("subject2[2] == 2", subject2[2] == 2);
    test_true("subject2[3] == 3", subject2[3] == 3);
    test_true("subject2[4] == 4", subject2[4] == 4);
    test_true("subject2[5] == 5", subject2[5] == 5);
    test_true("subject2[6] == 6", subject2[6] == 6);
    test_true("subject2[7] == 7", subject2[7] == 7);
    test_true("subject2[8] == 8", subject2[8] == 8);
    test_true("subject2[9] == 9", subject2[9] == 9);

  }

  test_name = "move assignment";
  {
    subject:vector[int];
    subject.push_back(4);
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)

    test_true("subject2.size() == 10", subject2.size() == 10);
    test_true("subject.size() == 1", subject.size() == 1);
    subject = move(subject2);
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject2.size() == 10", subject2.size() == 0);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "move assignment (empty)";
  {
    subject:vector[int];
    subject.push_back(4);
    subject2:vector[int];

    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject2.size() == 0", subject2.size() == 0);
    subject = move(subject2);
    test_true("subject.size() == 0", subject.size() == 0);
    test_true("subject2.size() == 0", subject2.size() == 0);
  }


  test_name = "copy constructor";
  {
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)

    subject:vector[int] = subject2;
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject2.size() == 10", subject2.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
    # Making sure the original is still the same.
    test_true("subject2[0] == 0", subject2[0] == 0);
    test_true("subject2[1] == 1", subject2[1] == 1);
    test_true("subject2[2] == 2", subject2[2] == 2);
    test_true("subject2[3] == 3", subject2[3] == 3);
    test_true("subject2[4] == 4", subject2[4] == 4);
    test_true("subject2[5] == 5", subject2[5] == 5);
    test_true("subject2[6] == 6", subject2[6] == 6);
    test_true("subject2[7] == 7", subject2[7] == 7);
    test_true("subject2[8] == 8", subject2[8] == 8);
    test_true("subject2[9] == 9", subject2[9] == 9);

  }


  test_name = "move constructor";
  {
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)

    subject:vector[int] = move(subject2);
    test_true("subject2.size() == 0", subject2.size() == 0);
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "max size ";
  {
    subject:vector[int];
    test_true("subject.max_size() == (vector[int].size_type(-1)/sizeof(int))",
              subject.max_size() == (vector[int].size_type(-1)/sizeof(int)));
  }

  test_name = "default size constructor";
  {
    subject = vector[int](4);
    test_true("subject.size() == 4", subject.size() == 4);
  }

  test_name = "default size constructor 2";
  {
    subject:vector[int] = vector[int](4);
    test_true("subject.size() == 4", subject.size() == 4);
  }

  test_name = "default size with value";
  {
    subject = vector[int](uint64(4), 1);
    test_true("subject.size() == 4", subject.size() == 4);
    test_true("subject[0] == 1", subject[0] == 1);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 1", subject[2] == 1);
    test_true("subject[3] == 1", subject[3] == 1);
  }

  test_name = "default size with value 2";
  {
    subject:vector[int] = vector[int](uint64(4), 1);
    test_true("subject.size() == 4", subject.size() == 4);
    test_true("subject[0] == 1", subject[0] == 1);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 1", subject[2] == 1);
    test_true("subject[3] == 1", subject[3] == 1);
  }

  test_name = "range constructor";
  {
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)

    subject:vector[int] = vector[int](subject2.begin(), subject2.end());
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject2.size() == 10", subject2.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
    # Making sure the original is still the same.
    test_true("subject2[0] == 0", subject2[0] == 0);
    test_true("subject2[1] == 1", subject2[1] == 1);
    test_true("subject2[2] == 2", subject2[2] == 2);
    test_true("subject2[3] == 3", subject2[3] == 3);
    test_true("subject2[4] == 4", subject2[4] == 4);
    test_true("subject2[5] == 5", subject2[5] == 5);
    test_true("subject2[6] == 6", subject2[6] == 6);
    test_true("subject2[7] == 7", subject2[7] == 7);
    test_true("subject2[8] == 8", subject2[8] == 8);
    test_true("subject2[9] == 9", subject2[9] == 9);

  }

  test_name = "assign size and value";
  {
    subject = vector[int]();
    subject.assign(uint64(4), 1);
    test_true("subject.size() == 4", subject.size() == 4);
    test_true("subject[0] == 1", subject[0] == 1);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 1", subject[2] == 1);
    test_true("subject[3] == 1", subject[3] == 1);
  }

  test_name = "assign range";
  {
    subject2:vector[int];
    for (x in 0..9):
      subject2.push_back(x)
    subject:vector[int];
    subject.assign(subject2.begin(), subject2.end());
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "resize to smaller then current";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)

    subject.resize(3);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "resize to larger then current";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)

    subject.resize(20);
    test_true("subject.size() == 20", subject.size() == 20);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "resize to smaller then current with value";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)

    subject.resize(3, 20);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "resize to larger then current with value";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)

    subject.resize(12, 20);
    test_true("subject.size() == 12", subject.size() == 12);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
    test_true("subject[10] == 20", subject[10] == 20);
    test_true("subject[11] == 20", subject[11] == 20);

  }

  test_name = "resize to larger then current with value";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)

    test_true("subject.capacity() == 16", subject.capacity() == 16);
    subject.shrink_to_fit();
    test_true("subject.capacity() == 10", subject.capacity() == 10);
    test_true("subject.size() == 10", subject.size() == 10);

  }

  test_name = "empty";
  {
    subject:vector[int];
    test_true("subject.empty()", subject.empty());
    subject.push_back(3)

    test_true("!subject.empty()", !subject.empty());
  }

  test_name = "reserve";
  {
    subject:vector[int];
    test_true("subject.capacity() == 0", subject.capacity() == 0);
    subject.reserve(20);
    test_true("subject.capacity() == 20", subject.capacity() == 20);
  }

  test_name = "operator []";
  {
    subject:vector[int];
    subject.push_back(1);
    test_true("subject[0] == 1", subject[0] == 1);
    subject[0] = 42
    test_true("subject[0] == 42", subject[0] == 42);
  }

  test_name = "at";
  {
    subject:vector[int];
    subject.push_back(1);
    test_true("subject.at(0) == 1", subject.at(0) == 1);
    subject.at(0) = 42
    test_true("subject.at(0) == 42", subject.at(0) == 42);
  }

  test_name = "at throws an exception";
  {
    subject:vector[int];
    subject.push_back(1);
    didThrow:bool = false;
    test_true("subject.at(0) == 1", subject.at(0) == 1);
    _{

      subject.at(2) = 42
    }catch() {
      didThrow = true;
    }
    test_true("didThrow", didThrow);
  }

  test_name = "front";
  {
    subject:vector[int];
    subject.push_back(1);
    test_true("subject.front() == 1", subject.front() == 1);
    subject.front() = 42
    test_true("subject.front() == 42", subject.front() == 42);
  }

  test_name = "back";
  {
    subject:vector[int];
    subject.push_back(1);
    test_true("subject.back() == 1", subject.back() == 1);
    subject.back() = 42
    test_true("subject.back() == 42", subject.back() == 42);
  }

  test_name = "back";
  {
    subject:vector[int];
    subject.push_back(1);
    test_true("subject.back() == 1", subject.back() == 1);
    subject.pop_back()
    test_true("subject.size() == 0", subject.size() == 0);
  }

  test_name = "emplace at beginning - only position";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin();
    subject.emplace(iter);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "emplace at beginning of empty vector";
  {
    subject:vector[int];
    iter = subject.begin();
    subject.emplace(iter);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 0", subject[0] == 0);
  }

  test_name = "emplace at end of empty vector";
  {
    subject:vector[int];
    iter = subject.end();
    subject.emplace(iter);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 0", subject[0] == 0);
  }

  test_name = "emplace at end of empty vector with value";
  {
    subject:vector[int];
    iter = subject.end();
    subject.emplace(iter, 23);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 23", subject[0] == 23);
  }

  test_name = "emplace in the middle of elements with args";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin() + 1;
    subject.emplace(iter, 23);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 1);
    test_true("subject[1] == 23", subject[1] == 23);
    test_true("subject[2] == 2", subject[2] == 2);
  }






  test_name = "insert at beginning";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin();
    subject.insert(iter, 0);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "insert at beginning of empty vector";
  {
    subject:vector[int];
    iter = subject.begin();
    subject.insert(iter, 2);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 2", subject[0] == 2);
  }

  test_name = "insert at end of empty vector";
  {
    subject:vector[int];
    iter = subject.end();
    subject.insert(iter, 2);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 2", subject[0] == 2);
  }

  test_name = "insert between elements";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin() + 1;
    subject.insert(iter, 23);
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 1);
    test_true("subject[1] == 23", subject[1] == 23);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "insert with move at beginning";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin();
    subject.insert(iter, move(0));
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
  }

  test_name = "insert with move at beginning of empty vector";
  {
    subject:vector[int];
    iter = subject.begin();
    subject.insert(iter, move(2));
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 2", subject[0] == 2);
  }

  test_name = "insert with move at end of empty vector";
  {
    subject:vector[int];
    iter = subject.end();
    subject.insert(iter, move(2));
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 2", subject[0] == 2);
  }

  test_name = "insert with move between elements";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin() + 1;
    subject.insert(iter, move(23));
    test_true("subject.size() == 3", subject.size() == 3);
    test_true("subject[0] == 0", subject[0] == 1);
    test_true("subject[1] == 23", subject[1] == 23);
    test_true("subject[2] == 2", subject[2] == 2);
  }




  test_name = "insert number n times at beginning";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin();
    subject.insert(iter, uint64(4), 0);
    test_true("subject.size() == 6", subject.size() == 6);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 0", subject[1] == 0);
    test_true("subject[2] == 0", subject[2] == 0);
    test_true("subject[3] == 0", subject[3] == 0);
    test_true("subject[4] == 1", subject[4] == 1);
    test_true("subject[5] == 2", subject[5] == 2);
  }

  test_name = "insert number n times at beginning of empty vector";
  {
    subject:vector[int];
    iter = subject.begin();
    subject.insert(iter, uint64(1), 0);
    test_true("subject.size() == 1", subject.size() == 1);
    test_true("subject[0] == 0", subject[0] == 0);
  }

  test_name = "insert number n times at end of empty vector";
  {
    subject:vector[int];
    iter = subject.end();
    subject.insert(iter, uint64(2), 2);
    test_true("subject.size() == 2", subject.size() == 2);
    test_true("subject[0] == 2", subject[0] == 2);
    test_true("subject[1] == 2", subject[1] == 2);
  }

  test_name = "insert number n times between elements";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin() + 1;
    subject.insert(iter, uint64(2), 13);
    test_true("subject.size() == 4", subject.size() == 4);
    test_true("subject[0] == 0", subject[0] == 1);
    test_true("subject[1] == 13", subject[1] == 13);
    test_true("subject[2] == 13", subject[2] == 13);
    test_true("subject[3] == 2", subject[3] == 2);
  }


  test_name = "insert range at beginning";
  {

    input:vector[int];
    for (x in 0..9):
      input.push_back(x)

    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin();
    subject.insert(iter, input.begin(), input.end());
    test_true("subject.size() == 12", subject.size() == 12);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
    test_true("subject[10] == 1", subject[10] == 1);
    test_true("subject[11] == 2", subject[11] == 2);
  }

  test_name = "insert range at beginning of empty vector";
  {
    input:vector[int];
    for (x in 0..9):
      input.push_back(x)
    subject:vector[int];
    iter = subject.begin();
    subject.insert(iter, input.begin(), input.end());
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "insert range at end of empty vector";
  {
    input:vector[int];
    for (x in 0..9):
      input.push_back(x)
    subject:vector[int];
    iter = subject.end();
    subject.insert(iter, input.begin(), input.end());
    test_true("subject.size() == 10", subject.size() == 10);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 1", subject[1] == 1);
    test_true("subject[2] == 2", subject[2] == 2);
    test_true("subject[3] == 3", subject[3] == 3);
    test_true("subject[4] == 4", subject[4] == 4);
    test_true("subject[5] == 5", subject[5] == 5);
    test_true("subject[6] == 6", subject[6] == 6);
    test_true("subject[7] == 7", subject[7] == 7);
    test_true("subject[8] == 8", subject[8] == 8);
    test_true("subject[9] == 9", subject[9] == 9);
  }

  test_name = "insert range between elements";
  {
    input:vector[int];
    for (x in 0..9):
      input.push_back(x)
    subject:vector[int];
    subject.push_back(1)
    subject.push_back(2)
    iter = subject.begin() + 1;
    subject.insert(iter, input.begin(), input.end());
    test_true("subject.size() == 12", subject.size() == 12);

    test_true("subject[0] == 1", subject[0] == 1);
    test_true("subject[1] == 0", subject[1] == 0);
    test_true("subject[2] == 1", subject[2] == 1);
    test_true("subject[3] == 2", subject[3] == 2);
    test_true("subject[4] == 3", subject[4] == 3);
    test_true("subject[5] == 4", subject[5] == 4);
    test_true("subject[6] == 5", subject[6] == 5);
    test_true("subject[7] == 6", subject[7] == 6);
    test_true("subject[8] == 7", subject[8] == 7);
    test_true("subject[9] == 8", subject[9] == 8);
    test_true("subject[10] == 9", subject[10] == 9);
    test_true("subject[11] == 2", subject[11] == 2);
  }

  test_name = "erase first element";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)
    subject.erase(subject.begin())
    test_true("subject.size() == 9", subject.size() == 9);
    test_true("subject[0] == 1", subject[0] == 1);
    test_true("subject[1] == 2", subject[1] == 2);
    test_true("subject[2] == 3", subject[2] == 3);
    test_true("subject[3] == 4", subject[3] == 4);
    test_true("subject[4] == 5", subject[4] == 5);
    test_true("subject[5] == 6", subject[5] == 6);
    test_true("subject[6] == 7", subject[6] == 7);
    test_true("subject[7] == 8", subject[7] == 8);
    test_true("subject[8] == 9", subject[8] == 9);
  }

  test_name = "erase 2 nd element";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)
    subject.erase(subject.begin() + 1)
    test_true("subject.size() == 9", subject.size() == 9);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 2", subject[1] == 2);
    test_true("subject[2] == 3", subject[2] == 3);
    test_true("subject[3] == 4", subject[3] == 4);
    test_true("subject[4] == 5", subject[4] == 5);
    test_true("subject[5] == 6", subject[5] == 6);
    test_true("subject[6] == 7", subject[6] == 7);
    test_true("subject[7] == 8", subject[7] == 8);
    test_true("subject[8] == 9", subject[8] == 9);
  }

  test_name = "erase only element";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.erase(subject.begin())
    test_true("subject.size() == 0", subject.size() == 0);
  }

  test_name = "erase end";
  {
    subject:vector[int];
    subject.push_back(1)
    subject.erase(subject.end())
    test_true("subject.size() == 1", subject.size() == 1);
  }



  test_name = "erase entire range";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)
    subject.erase(subject.begin(), subject.end())
    test_true("subject.size() == 0", subject.size() == 0);
  }

  test_name = "erase middle elements";
  {
    subject:vector[int];
    for (x in 0..9):
      subject.push_back(x)
    subject.erase(subject.begin() + 1, subject.end() - 1)
    test_true("subject.size() == 2", subject.size() == 2);
    test_true("subject[0] == 0", subject[0] == 0);
    test_true("subject[1] == 9", subject[1] == 9);
  }

  <#
  erase(first:iterator, last:iterator):void!
  swap(other:ref vector[T, Alloc])<noexcept>:void

  constructor(a:ref const allocator_type)<explicit><noexcept>!
  #>

  total_tests_count = failed_test_count + passed_test_count;
  print("Tests completed: %d\n", (total_tests_count));
  print("Tests Passed: %d\n", (passed_test_count));
  print("Tests Failed: %d\n", (failed_test_count));
  if (failed_test_count <> 0) {
    return 1;
  }
  return 0;
}