// Nodes
//
// A node is basically a pair of a class name and its variable name. To add
// a new node, define the pair here, and undef it at the end of the file.

// def_syntax(T, B)
// def_abstract(T, B)
//
// The two parameters are the class name and its base class name.

#ifndef def_syntax
#  define def_syntax(T, B)
#endif

#ifndef def_abstract
#  define def_abstract(T, B)
#endif

/// First must be the FIRST concrete derived class that's given with def_syntax
/// after any number of uses of def_non_leaf_start.
#ifndef def_non_leaf_start
#  define def_non_leaf_start(T, First)
#endif


/// Last is the last concrete derived class enumeration specified by def_syntax
/// before def_non_leaf_end is used.
#ifndef def_non_leaf_end
#  define def_non_leaf_end(T, Last)
#endif


// The order that this is specified in matters, this is used to signify the
// inheritance structure of the syntax classes, in order for this to work
// to HAVE TO MIRROR the inheritance structure within this file.


// The def_non_leaf_start and  def_non_leaf_end macros are specifically used
// to keep track of the range that is specified concrete derived classes
// that are available.

def_abstract(Unary, Syntax)
def_non_leaf_start(Unary, Enclosure)
  def_syntax(Enclosure, Unary)
  def_syntax(Prefix, Unary)
  def_syntax(Postfix, Unary)
  def_syntax(BuiltinCompilerOp, Unary)
  def_syntax(CppCodeBlock, Unary)
  def_syntax(CppInclude, Unary)
  def_syntax(File, Unary)
def_non_leaf_end(Unary, File)

// Binary syntax.
def_abstract(Binary, Syntax)
def_non_leaf_start(Binary, Pair)

  def_syntax(Pair, Binary)
  def_abstract(Constructor, Binary)
  def_non_leaf_start(Constructor, Array)
    def_syntax(Array, Constructor)

    def_abstract(Mapping, Syntax)
    def_non_leaf_start(Mapping, Function)
      def_syntax(Function, Constructor)
      def_syntax(Template, Constructor)
    def_non_leaf_end(Mapping, Template)
  def_non_leaf_end(Constructor, Template)

  def_abstract(Application, Binary)
  def_non_leaf_start(Application, Call)
    def_syntax(Call, Application)
    def_syntax(Index, Application)
  def_non_leaf_end(Application, Index)

  def_syntax(Infix, Binary)
  def_syntax(Control, Binary)
def_non_leaf_end(Binary, Control)

def_abstract(Ternary, Syntax)
def_non_leaf_start(Ternary, Triple)
  def_syntax(Triple, Ternary)
  def_syntax(QualifiedMemberAccess, Triple)
def_non_leaf_end(Ternary, Triple)

// KarySyntax<4>
def_abstract(Quaternary, Syntax)
def_non_leaf_start(Quaternary, Declaration)
  def_syntax(Declaration, Syntax)
  def_syntax(Quadruple, Quaternary)
def_non_leaf_end(Quaternary, Quadruple)

// Dynamic structures
def_abstract(Multiary, Syntax)
def_non_leaf_start(Multiary, List)
  // Lists, sequences, and enclosures
  def_syntax(List, Multiary)
  def_syntax(Sequence, Multiary)
def_non_leaf_end(Multiary, Sequence)

// Atomic nodes
def_abstract(Atom, Syntax)
def_non_leaf_start(Atom, Literal)
  def_syntax(Literal, Atom)
  def_syntax(Identifier, Atom)
def_non_leaf_end(Atom, Identifier)

def_syntax(TokenList, Syntax)


#undef def_syntax
#undef def_abstract
#undef def_non_leaf_start
#undef def_non_leaf_end