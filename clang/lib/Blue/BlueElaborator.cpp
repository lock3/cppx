//===- BlueElaborator.cpp - Blue Language Elaborator ----------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Copyright (c) Lock3 Software 2019, all rights reserved.
//
//===----------------------------------------------------------------------===//
//
//  Translates concrete syntax into C++ AST trees.
//
//===----------------------------------------------------------------------===//

#include "clang/Blue/BlueElaborator.h"
#include "clang/Blue/BlueSyntax.h"
#include "clang/Blue/BlueDeclarator.h"
#include "clang/Basic/Diagnostic.h"

#include "clang/AST/Expr.h"
#include "clang/AST/ExprCppx.h"
#include "clang/AST/ExprCXX.h"
#include "clang/AST/OperationKinds.h"
#include "clang/AST/Stmt.h"
#include "clang/AST/Type.h"
#include "clang/Basic/Builtins.h"
#include "clang/Basic/CharInfo.h"
#include "clang/Basic/DiagnosticParse.h"
#include "clang/Basic/DiagnosticSema.h"
#include "clang/Basic/SourceLocation.h"
#include "clang/Basic/TargetInfo.h"
#include "clang/Lex/LexDiagnostic.h"
#include "clang/Lex/LiteralSupport.h"
#include "clang/Sema/CXXFieldCollector.h"
#include "clang/Sema/DeclSpec.h"
#include "clang/Sema/Lookup.h"
#include "clang/Sema/Ownership.h"
#include "clang/Sema/ParsedTemplate.h"
#include "clang/Sema/ScopeInfo.h"
#include "clang/Sema/Sema.h"
#include "clang/Sema/Template.h"
#include "clang/Sema/TypeLocBuilder.h"
#include "clang/Sema/TypeLocUtil.h"
#include "llvm/ADT/APSInt.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/Support/Error.h"

#include <iostream>

namespace blue {

Declaration *Elaborator::createDeclaration(const Syntax *Def,
                                           Declarator *Dcl,
                                           const Syntax *Init) {
  Declaration *TheDecl =
    new Declaration(SemaRef.getCurrentDecl(), Def, Dcl, Init);


  if (const DefSyntax *Id = dyn_cast<DefSyntax>(Def))
    TheDecl->Id = &SemaRef.getCxxAST().Idents.get({Id->getIdentifierSpelling()});
  else if (const IdentifierSyntax *Id = dyn_cast<IdentifierSyntax>(Def))
    TheDecl->Id = &SemaRef.getCxxAST().Idents.get({Id->getSpelling()});

  Scope *CurScope = SemaRef.getCurrentScope();
  CurScope->addDecl(TheDecl);
  TheDecl->DeclaringContext = SemaRef.getCurClangDeclContext();
  TheDecl->ScopeForDecl = CurScope;
  TheDecl->ClangDeclaringScope = SemaRef.getCurClangScope();

  return TheDecl;
}

clang::Decl *Elaborator::elaborateTop(const Syntax *S) {
  if (!S)
    return nullptr;

  // This is missed during initialziation because of the language setting.
  SemaRef.getCxxSema().FieldCollector.reset(new clang::CXXFieldCollector());
  // Setting up clang scopes.
  clang::Scope *Scope = SemaRef.enterClangScope(clang::Scope::DeclScope);
  Scope->setEntity(getCxxContext().getTranslationUnitDecl());
  SemaRef.getCxxSema().ActOnTranslationUnitScope(Scope);
  SemaRef.getCxxSema().Initialize();

  // Count the decls generated by clang::Sema::Initialize().
  clang::TranslationUnitDecl *TU = getCxxContext().getTranslationUnitDecl();
  for (auto D = TU->decls_begin(); D != TU->decls_end(); ++D)
    ++ImplicitSemaDecls;

  Declaration *D = new Declaration(S);
  D->setCxx(SemaRef, TU);
  D->SavedScope = SemaRef.getCurrentScope();


  const TopSyntax *Top = cast<TopSyntax>(S);
  Sema::ScopeRAII NamespaceScope(SemaRef, Scope::Namespace, S);
  SemaRef.pushDecl(D);
  for (const Syntax *SS : Top->children()) {
      identifyDeclaration(SS);
  }

  for (const Syntax *SS : Top->children())
      elaborateDecl(SS);

  for (const Syntax *SS : Top->children())
    elaborateDefinition(SS);

  SemaRef.getCxxSema().ActOnEndOfTranslationUnit();
  SemaRef.popDecl();

  return TU;
}

void Elaborator::buildDeclaration(const DefSyntax *S) {
  Declarator *Dcl = getDeclarator(S->getDeclarator());
  createDeclaration(S, Dcl, S->getInitializer());
}

void Elaborator::identifyDeclaration(const Syntax *S) {
  switch (S->getKind()) {
  case Syntax::Def:
    return buildDeclaration(cast<DefSyntax>(S));
  default:
    break;
  }

}

clang::Decl* Elaborator::elaborateDecl(const Syntax *S) {
  switch (S->getKind()) {
  case Syntax::Def:
    return elaborateDefDecl(static_cast<const DefSyntax *>(S));
  default:
    break;
  }
  // TODO: Remove this eventaully, when we are not doing elaboration.
  // This will allow us to pretend to evaluate expressions inside the global
  // scope of a probram.
  return nullptr;
  // llvm_unreachable("invalid declaration");
}


clang::Decl *Elaborator::elaborateDefDecl(const DefSyntax *S) {
  Declaration *D = SemaRef.getCurrentScope()->findDecl(S);
  if (!D)
    return nullptr;

  return elaborateDeclarationTyping(D);
}

clang::Decl *Elaborator::elaborateDeclarationTyping(Declaration *D) {
  if (phaseOf(D) >= Phase::Typing)
    return D->getCxx();

  if (D->Decl->declaresValue())
    return makeValueDecl(D);

  if (D->Decl->declaresFunction())
    return makeFunctionDecl(D);

  if (D->declaratorContainsClass())
    return makeClass(D);

  // Not sure if this is the right way to handle this or not?
  // if (D->Decl->declaresTemplate())
  //   return makeTemplateDecl(D);


  llvm_unreachable("Invalid declarator");
}

void Elaborator::elaborateParameters(const ListSyntax *S) {
  if (S->isSemicolonSeparated())
    return elaborateParameterGroup(S);
  else
    return elaborateParameterList(S);
}

void Elaborator::getParameters(Declaration *D,
                          llvm::SmallVectorImpl<clang::ParmVarDecl *> &Params) {
  assert(D->Decl->declaresFunction());
  const ListSyntax *ParamList = dyn_cast<ListSyntax>(D->Decl->getInfo());
  if (!ParamList)
    return;

  // FIXME: implement me
  if (ParamList->isSemicolonSeparated())
    return;

  Scope *S = D->Decl->DeclInfo.ParamScope;
  for (const Syntax *SS : ParamList->children()) {
    Declaration *Param = S->findDecl(SS);
    // FIXME: elaborate the entire function type if this happens?
    if (!Param)
      continue;
    assert(isa<clang::ParmVarDecl>(Param->getCxx()));
    Params.push_back(cast<clang::ParmVarDecl>(Param->getCxx()));
  }
}

void Elaborator::elaborateParameterGroup(const ListSyntax *S) {
  for (const Syntax *SS : S->children())
    elaborateParameterList(cast<ListSyntax>(SS));
}

void Elaborator::elaborateParameterList(const ListSyntax *S) {
  for (const Syntax *SS : S->children())
    elaborateParameter(SS);

  // FIXME: Examine the parameters we just created. We might be able
  // to back-propagate types to some of them. For example, if we have;
  //
  //    a, b : int
  //
  // Then this should be equivalent to a : int, b: int.
}

clang::Decl *Elaborator::elaborateParameter(const Syntax *S) {
  if (!isa<DefSyntax>(S) && !isa<IdentifierSyntax>(S)) {
    Error(S->getLocation(), "invalid parameter syntax");
    return nullptr;
  }

  clang::ASTContext &CxxAST = SemaRef.getCxxAST();
  clang::SourceLocation Loc = S->getLocation();

  if (const IdentifierSyntax *Id = dyn_cast<IdentifierSyntax>(S)) {
    // FIXME: create context for auto parameters to keep track of their
    // index and depth.
    Declaration *TheDecl = createDeclaration(S, nullptr, nullptr);

    clang::IdentifierInfo *II = &CxxAST.Idents.get({Id->getSpelling()});
    clang::IdentifierInfo *TypeName =
      CxxSema.InventAbbreviatedTemplateParameterTypeName(II, TempCtx.Index);

    using clang::TemplateTypeParmDecl;
    TemplateTypeParmDecl *TheType =
      TemplateTypeParmDecl::Create(CxxAST, CxxAST.getTranslationUnitDecl(),
                                   clang::SourceLocation(),
                                   Id->getLocation(), TempCtx.Depth,
                                   TempCtx.Index, TypeName, /*Typename=*/false,
                                   /*ParameterPack=*/false);
    TheType->setImplicit();
    ++TempCtx.Index;

    clang::CppxTypeLiteral *TyLit =
      SemaRef.buildTypeExpr(clang::QualType(TheType->getTypeForDecl(), 0),
                            Id->getLocation());
    clang::DeclarationName Name(II);
    clang::TypeSourceInfo *T = cast<clang::CppxTypeLiteral>(TyLit)->getValue();
    clang::DeclContext *Owner = SemaRef.getCurClangDeclContext();
    clang::ParmVarDecl *PVD =
      clang::ParmVarDecl::Create(CxxAST, Owner, Loc, Loc,
                                 Name, T->getType(), T,
                                 clang::SC_Auto, /*def=*/nullptr);
    TheDecl->setCxx(SemaRef, PVD);
    return PVD;
  }

  // FIXME: There is a lot of duplication with makeObjectDecl here.
  // In Gold it's just one function.
  const auto *Def = cast<DefSyntax>(S);
  Declarator *Dcl = getDeclarator(Def->getDeclarator());
  clang::Expr *Ty = elaborateDeclarator(Dcl);
  if (!Ty)
    return nullptr;

  // FIXME: This needs to be refactored so it's created during phase identification.
  // Create the Blue Declaration
  Declaration *TheDecl = createDeclaration(Def, Dcl, Def->getInitializer());

  // Create the Clang Decl Node
  clang::IdentifierInfo *Id = TheDecl->Id;
  clang::DeclarationName Name(Id);

  if(!Ty->getType()->isTypeOfTypes()) {
    Error(Ty->getExprLoc(), "expected type");
    return nullptr;
  }

  clang::TypeSourceInfo *T = cast<clang::CppxTypeLiteral>(Ty)->getValue();
  // Create the parameters in the translation unit decl for now, we'll
  // move them into the function later.
  // FIXME: replace this with TU
  clang::DeclContext *Owner = SemaRef.getCurClangDeclContext();
  clang::ParmVarDecl *PVD =
    clang::ParmVarDecl::Create(CxxAST, Owner, Loc, Loc,
                               Name, T->getType(), T,
                               clang::SC_Auto, /*def=*/nullptr);
  TheDecl->setCxx(SemaRef, PVD);
  return PVD;
}


// Declarator construction

// A declarator is a sequence of unary (pointer) and binary (application)
// operators that can be linearized to describe a declaration.
//
// For applications, the left-hand side of a binary operator is always a
// parameter or type list describing a function or template (i.e., mapping)
// type. The right hand side denotes the type or kind of value produced by
// the function's evaluation or instantiation.
//
// For pointers, the operand is the type of object pointed at.
//
// The right-most leaf of the tree ultimately determines the type of the
// object accessed by the declaration.
//
// The first term in the list is always an identifier, which is established
// by the function above.
Declarator *Elaborator::getDeclarator(const Syntax *S) {
  if (!S)
    return getImplicitAutoDeclarator();

  if (const auto *U = dyn_cast<UnarySyntax>(S))
    return getUnaryDeclarator(U);
  if (const auto* B = dyn_cast<BinarySyntax>(S))
    return getBinaryDeclarator(B);
  return getLeafDeclarator(S);
}

Declarator *Elaborator::getUnaryDeclarator(const UnarySyntax *S) {
  if (S->getOperator().hasKind(tok::Caret)) {
    Declarator *Dcl = getDeclarator(S->getOperand());
    return new Declarator(Declarator::Pointer, S, Dcl);
  }

  Error(S->getLocation(), "invalid operator in declarator");
  return nullptr;
}

Declarator *Elaborator::getBinaryDeclarator(const BinarySyntax *S) {
  if (S->isApplication())
    return new Declarator(Declarator::Type, S);

  if (S->getOperator().hasKind(tok::MinusGreater)) {
    Declarator *Ret = getDeclarator(S->getRightOperand());
    return new Declarator(Declarator::Function, S->getLeftOperand(), Ret);
  }

  // TODO: We could support binary type composition (e.g., T1 * T2) as
  // an alternative spelling of product types. However, this most likely
  // needs to be wrapped in parens, so it should end up as a leaf. Maybe
  // this is a non-issue.
  Error(S->getLocation(), "invalid operator in declarator");
  return nullptr;
}

Declarator *Elaborator::getLeafDeclarator(const Syntax *S) {
  switch (S->getKind()) {
  case Syntax::Literal: {
    auto Lit = dyn_cast<LiteralSyntax>(S);
    if (Lit->getToken().hasKind(tok::ClassKeyword)) {
      return new Declarator(Declarator::Class, S);
    }
  }
  LLVM_FALLTHROUGH;
  case Syntax::Identifier:
    return new Declarator(Declarator::Type, S);
  case Syntax::List:
    return new Declarator(Declarator::Function, S);
  default:
    break;
  }
  llvm_unreachable("Invalid type expression");
}

Declarator *Elaborator::getImplicitAutoDeclarator() {
  return new Declarator(Declarator::ImplicitType, nullptr);
}

clang::Decl *Elaborator::elaborateDeclEarly(Declaration *D) {
  auto *Ret = elaborateDeclarationTyping(D);
  if (SemaRef.DeepElaborationMode)
    elaborateDefinitionInitialization(D);
  return Ret;
}

// Declaration construction

clang::Decl *Elaborator::makeValueDecl(Declaration *D) {
  // Elaborate the declarator.
  //
  // FIXME: An ill-typed declaration isn't the end of the world. Can we
  // poison the declaration and move on?
  clang::Expr *E = elaborateDeclarator(D->Decl);
  if (!E)
    return nullptr;

  Sema::DeclarationElaborationRAII DeclElab(SemaRef, D);
  clang::QualType T;
  if (E->getType()->isTypeOfTypes())
    T = cast<clang::CppxTypeLiteral>(E)->getValue()->getType();

  Sema::DeepElaborationModeRAII ElabMode(SemaRef, false);
  if (T->isUndeducedType()) {
    ElabMode.setMode(true);
    // Doing a quick check to see if the RHS is a type expression.
    if (D->hasInitializer()) {
      auto E = elaborateExpression(D->getInitializer());
      if (!E)
        // TODO: May want an invalid declaration error here.
        return nullptr;

      if (E->getType()->isKindType()) {
        return makeTypeDecl(D, T);
      }
    }
  }
  if (T->isKindType()) {
    ElabMode.setMode(true);
    return makeTypeDecl(D, T);
  } else {
    // Handling field declarations slightly different then variable declarations.
    if (D->declaredWithinClassBody())
      return makeFieldDecl(D, E);
    // Need to check if the declaration is auto because if that's the
    // case we need to force early elaboration instead of letting it go.
    return makeObjectDecl(D, E);
  }
}

static inline clang::StorageClass getDefaultVariableStorageClass(Sema &SemaRef) {
  return SemaRef.getCurrentScope()->isBlockScope() ||
    SemaRef.getCurrentScope()->isControlScope()
    ? clang::SC_Auto
    : clang::SC_None;
}

clang::Decl *Elaborator::makeObjectDecl(Declaration *D, clang::Expr *Ty) {
  const DefSyntax *Def = D->asDef();
  if (!Def)
    return nullptr;

  // Create the Clang Decl Node
  clang::ASTContext &CxxAST = SemaRef.getCxxAST();
  clang::IdentifierInfo *Id = D->Id;
  clang::DeclarationName Name(Id);
  clang::SourceLocation Loc = D->Def->getLocation();

  assert(Ty->getType()->isTypeOfTypes() && "type of declaration is not a type");
  clang::TypeSourceInfo *T = cast<clang::CppxTypeLiteral>(Ty)->getValue();

  clang::DeclContext *Owner = SemaRef.getCurClangDeclContext();
  clang::VarDecl *VD =
    clang::VarDecl::Create(CxxAST, Owner, Loc, Loc, Id, T->getType(), T,
                           getDefaultVariableStorageClass(SemaRef));
  Owner->addDecl(VD);
  D->setCxx(SemaRef, VD);
  D->CurrentPhase = Phase::Typing;
  // Checking for redeclaration, this will emit an error message if this is a
  // duplicate variable within the same current scope.
  SemaRef.checkForRedeclaration(D);

  if (SemaRef.DeepElaborationMode)
    elaborateDefinitionInitialization(D);
  return VD;
}

clang::Decl *Elaborator::makeTypeDecl(Declaration *D, clang::QualType T) {
  if (!D->hasInitializer()) {
    SemaRef.getCxxSema().Diags.Report(D->Def->getLocation(),
                                      clang::diag::err_expected_type);
    return nullptr;
  }
  const Syntax *Init = D->getInitializer();
  clang::Expr *TyExpr = elaborateExpression(Init);
  if (!TyExpr)
    return nullptr;
  clang::ParsedType PT;
  clang::TypeSourceInfo *TInfo =
    SemaRef.getTypeSourceInfoFromExpr(TyExpr, Init->getLocation());
  if (!TInfo)
    return nullptr;

  PT = SemaRef.getCxxSema().CreateParsedType(TInfo->getType(), TInfo);
  D->CurrentPhase = Phase::Initialization;

  clang::IdentifierInfo *IdInfo = D->Id;
  clang::UnqualifiedId Id;
  Id.setIdentifier(IdInfo, D->Def->getBeginLocation());
  clang::SourceLocation Loc = Init->getLocation();
  clang::MultiTemplateParamsArg MTP;


  // Constructing the type alias on the way out because we need to correctly
  // construct its internal type before continuing.
  clang::TypeResult TR(PT);
  clang::Decl *TypeAlias = SemaRef.getCxxSema().ActOnAliasDeclaration(
      SemaRef.getCurClangScope(), clang::AS_public, MTP, Loc, Id,
      clang::ParsedAttributesView(), TR, nullptr);
  D->setCxx(SemaRef, TypeAlias);
  // SemaRef.addDeclToDecl(TypeAlias, D);
  SemaRef.checkForRedeclaration(D);
  return TypeAlias;
}

clang::CppxTypeLiteral *Elaborator::createFunctionType(Declarator *Dcl) {
  const ListSyntax *ParamList = dyn_cast<ListSyntax>(Dcl->getInfo());
  if (!ParamList)
    return nullptr;
  clang::SourceLocation Loc = ParamList->getLocation();
  clang::ASTContext &CxxAST = SemaRef.getCxxAST();
  Sema::ScopeRAII ParamScope(SemaRef, Scope::Parameter, ParamList);
  Dcl->DeclInfo.ParamScope = SemaRef.getCurrentScope();

  elaborateParameters(ParamList);

  unsigned N = ParamList->getNumChildren();
  llvm::SmallVector<clang::QualType, 4> Types;
  llvm::SmallVector<clang::ParmVarDecl *, 4> Params;
  for (unsigned I = 0; I < N; ++I) {
    const Syntax *P = ParamList->getChild(I);
    Declaration *BluePD = SemaRef.getCurrentScope()->findDecl(P);
    assert(BluePD && "associated declaration never found");
    assert(isa<clang::ParmVarDecl>(BluePD->getCxx()) &&
           "Parameter is not a ParmVarDecl");
    clang::ParmVarDecl *PVD = cast<clang::ParmVarDecl>(BluePD->getCxx());

    CxxAST.setParameterIndex(PVD, I);
    PVD->setScopeInfo(0, I);
    Types.push_back(PVD->getType());
    Params.push_back(PVD);
  }

  // FIXME: We need to configure parts of the prototype (e.g., noexcept).
  clang::FunctionProtoType::ExtProtoInfo EPI;
  clang::QualType ReturnType = CxxAST.getAutoDeductType();
  if (Dcl->getNext()) {
    clang::Expr *RetExpr = elaborateDeclarator(Dcl->getNext());
    if (!RetExpr)
      return nullptr;
    if (!RetExpr->getType()->isTypeOfTypes()) {
      Error(RetExpr->getExprLoc(), "expected type in function return");
      return nullptr;
    }

    clang::CppxTypeLiteral *RetTyLit = cast<clang::CppxTypeLiteral>(RetExpr);
    ReturnType = RetTyLit->getValue()->getType();
  }

  clang::QualType FnTy = CxxAST.getFunctionType(ReturnType, Types, EPI);
  return SemaRef.buildFunctionTypeExpr(FnTy, Loc, Loc, Loc,
                                       clang::SourceRange(Loc, Loc),
                                       Loc, Params);
}

clang::Decl *Elaborator::makeFunctionDecl(Declaration *D) {
  assert(D->Decl->declaresFunction() && "not a function declarator");

  clang::ASTContext &CxxAST = SemaRef.getCxxAST();
  clang::QualType ReturnType = CxxAST.getAutoDeductType();
  clang::DeclarationName Name(D->Id);
  clang::SourceLocation Loc = D->Def->getLocation();

  TemplateParamRAII TempParamContextGuard(TempCtx);
  clang::CppxTypeLiteral *FnTy = createFunctionType(D->Decl);
  if (!FnTy)
    return nullptr;
  clang::TypeSourceInfo *TInfo = FnTy->getValue();

  clang::FunctionDecl *FD;
  clang::DeclContext *Owner = SemaRef.getCurClangDeclContext();
  FD = clang::FunctionDecl::Create(CxxAST, Owner, Loc, Loc, Name,
                                   TInfo->getType(), TInfo, clang::SC_None);
  if (FD->isMain()) {
    clang::AttributeFactory Attrs;
    clang::DeclSpec DS(Attrs);
    CxxSema.CheckMain(FD, DS);
  }

  llvm::SmallVector<clang::ParmVarDecl *, 4> Params;
  getParameters(D, Params);
  FD->setParams(Params);
  // Move parameters into this declaration context.
  for (auto *PD : Params) {
    PD->setDeclContext(FD);
    PD->setOwningFunction(FD);
  }

  // CxxSema.CheckFunctionDeclaration(CxxScope, FD, Previous, false);
  // FIXME: this is not necessarily what should happen.
  if (FD->isInvalidDecl())
    return nullptr;

  Owner->addDecl(FD);
  D->setCxx(SemaRef, FD);
  D->CurrentPhase = Phase::Typing;
  return FD;
}

clang::Decl *Elaborator::makeClass(Declaration *D) {
  using namespace clang;
  D->CurrentPhase = Phase::Typing;

  // Checking if we are a nested template decl/class.
  bool WithinClass = D->ScopeForDecl->getKind() == blue::Scope::Class;
  MultiTemplateParamsArg MTP = D->TemplateParamStorage;

  bool IsOwned = false;
  bool IsDependent = false;
  CXXScopeSpec SS;
  TypeResult UnderlyingType;
  AccessSpecifier AS = AS_none;
  if (WithinClass)
    AS = AS_public;

  clang::SourceLocation IdLoc = D->Def->getLocation();
  clang::TypeSpecifierType TST = clang::DeclSpec::TST_struct;
  bool ScopeEnumUsesClassTag = false;
  clang::SourceLocation ScopedEnumClassKW;
  blue::Scope::Kind SK = blue::Scope::Class;
  // TODO: Refactor this so that we actually check the TST kind against
  // the class/enum/union identifier.
  // switch(D->getKind()) {
  // case UDK_Class:
  //   TST = clang::DeclSpec::TST_struct;
  //   break;
  // case UDK_Union:
  //   TST = clang::DeclSpec::TST_union;
  //   break;
  // case UDK_Enum:
  //   llvm_unreachable("");
  //   // TST = clang::DeclSpec::TST_enum;
  //   // ScopeEnumUsesClassTag = true;
  //   // if (const MacroSyntax *MS = dyn_cast<MacroSyntax>(D->Init)) {
  //   //   UnderlyingType = getUnderlyingEnumType(Context, SemaRef, MS->getCall());
  //   // } else {
  //   //   llvm_unreachable("Invalid tree syntax.");
  //   // }
  //   // ScopedEnumClassKW = D->IdDcl->getLoc();
  //   // SK = SK_Enum;
  //   break;
  // default:
  //   llvm_unreachable("Incorrectly identified tag type");
  // }

  Decl *Declaration = nullptr;
  // if (D->SpecializationArgs) {
  //   Declaration = handleClassSpecialization(Context, SemaRef, D, TST, MTP);
  // } else {
  Declaration = SemaRef.getCxxSema().ActOnTag(
    SemaRef.getCurClangScope(), TST, /*Metafunction=*/nullptr,
    clang::Sema::TUK_Definition, D->getInitializer()->getLocation(), SS, D->Id,
    IdLoc, clang::ParsedAttributesView(), AS,
    /*ModulePrivateLoc=*/SourceLocation(),
    MTP, IsOwned, IsDependent, ScopedEnumClassKW, ScopeEnumUsesClassTag,
    UnderlyingType, /*IsTypeSpecifier=*/false, /*IsTemplateParamOrArg=*/false);
  // }

  TagDecl *Tag = nullptr;
  if (!Declaration) {
    return nullptr;
  }
  if(isa<CXXRecordDecl>(Declaration)) {
    Tag = cast<CXXRecordDecl>(Declaration);
  } else if (isa<ClassTemplateDecl>(Declaration)) {
    ClassTemplateDecl *TempTemplateDecl = cast<ClassTemplateDecl>(Declaration);
    D->setCxx(SemaRef, TempTemplateDecl);
    Tag = cast<CXXRecordDecl>(TempTemplateDecl->getTemplatedDecl());
  } else if (isa<EnumDecl>(Declaration)) {
    Tag = cast<TagDecl>(Declaration);
  }

  D->setCxx(SemaRef, Tag);
  // Elab.elaborateAttributes(D);

  Sema::ScopeRAII ClassBodyScope(SemaRef, SK, D->Def, &D->SavedScope);
  SemaRef.getCurrentScope()->Entity = D;

  Sema::ClangScopeRAII ClangClassScopeBody(SemaRef,
            (Tag->isEnum() ? clang::Scope::EnumScope : clang::Scope::ClassScope)
                                           | clang::Scope::DeclScope,
                                           D->getInitializer()->getLocation());


  // Need to do this before the next step because this is actually pushed on to
  // the stack a by the next function called.
  SemaRef.getCxxSema().ActOnTagStartDefinition(SemaRef.getCurClangScope(), Tag);

  // This keeps the declContext working correctly.
  Sema::DeclContextRAII DCTracking(SemaRef, D, true);
  if (TST == clang::DeclSpec::TST_enum) {
    llvm_unreachable("Enum body not implemented yet.");
    // Elab.elaborateEnumBody(D, Tag);
    // if (Tag->isInvalidDecl()) {
    //   // Need to make sure that this isn't elaborated as a variable later on.
    //   D->CurrentPhase = Phase::Initialization;
    //   return Tag;
    // }
  } else {
    // This handles processing for class, struct, and union bodies.
    // This keeps track of class nesting.
    Sema::ElaboratingClassDefRAII ClsElabState(SemaRef, D,
                                              !SemaRef.isElaboratingClass());
    CXXRecordDecl *ClsDecl = cast<CXXRecordDecl>(Tag);
    identifyDeclsInClassBody(D, ClsDecl);
    // Attempt to figure out if any nested elaboration is actually required.
    // If not then we can proceed as normal.
    // auto const* MacroRoot = dyn_cast<MacroSyntax>(D->Init);
    // auto const* BodyArray = MacroRoot->getBlock();

    // Handling possible base classes.
    // if (const CallSyntax *ClsKwCall
    //                       = dyn_cast<CallSyntax>(MacroRoot->getCall())) {
    //   processBaseSpecifiers(Elab, SemaRef, Context, D, ClsDecl, ClsKwCall);
    // }
    // We turn this off here because technically we have already created the
    // most basic declaration that's required to use this type.
    D->IsElaborating = false;

    // This is really the only time we could possible allow this to occur.
    SemaRef.getCxxSema().ActOnStartCXXMemberDeclarations(
                                                     SemaRef.getCurClangScope(),
                                                         ClsDecl,
                                                         SourceLocation(), true,
                                                         SourceLocation());
    auto ClsDef = cast<DefSyntax>(D->Def);

    // Since all declarations have already been added, we don't need to do another
    // Reordering scan.
    // Doing possible delaying of member declaration/initialziation.
    for (const Syntax *SS : cast<SeqSyntax>(ClsDef->getInitializer())->children())
      delayElaborateDeclType(ClsDecl, SS);

    D->CurrentPhase = Phase::Initialization;
    if (!WithinClass) {
      ElaboratingClass &LateElabClass = SemaRef.getCurrentElaboratingClass();
      // Elab.finishDelayedElaboration(LateElabClass);
      lateElaborateAttributes(LateElabClass);
      lateElaborateMethodDecls(LateElabClass);
      lateElaborateDefaultParams(LateElabClass);
      // We call this because no new declarations can be added after this point.
      // This is only called for the top level class.
      SemaRef.getCxxSema().ActOnFinishCXXMemberDecls();

      SemaRef.getCxxSema().ActOnFinishCXXMemberSpecification(
        SemaRef.getCurClangScope(), SourceLocation(), ClsDecl, SourceLocation(),
        SourceLocation(), ParsedAttributesView());

      lateElaborateMemberInitializers(LateElabClass);
      lateElaborateMethodDefs(LateElabClass);
      SemaRef.getCxxSema().ActOnFinishCXXNonNestedClass(ClsDecl);
    } else {
      SemaRef.getCxxSema().ActOnFinishCXXMemberSpecification(
        SemaRef.getCurClangScope(), SourceLocation(), ClsDecl, SourceLocation(),
        SourceLocation(), ParsedAttributesView());
    }
  }

  clang::Decl *TempDeclPtr = Tag;
  SemaRef.getCxxSema().ActOnTagFinishDefinition(SemaRef.getCurClangScope(),
                                                TempDeclPtr, SourceRange());
  return Tag;
}

clang::Decl *Elaborator::makeTemplateDecl(Declaration *D) {
  llvm::outs() << "TEMPLATE!\n";
  return nullptr;
}

clang::Decl *Elaborator::makeFieldDecl(Declaration *D, clang::Expr *Ty) {
  auto TInfo = SemaRef.getTypeSourceInfoFromExpr(Ty, Ty->getExprLoc());
  if (!TInfo)
    return nullptr;
  clang::Decl *Ctxt = SemaRef.getCurrentDecl()->getCxx();
  clang::CXXRecordDecl *Owner = dyn_cast<clang::CXXRecordDecl>(Ctxt);
  // Get the type of the entity.
  if(!Owner) {
    // This occurs when we are within an extern "C" decl
    getCxxSema().Diags.Report(D->Def->getLocation(),
                              clang::diag::err_invalid_extern_c)
                              << /* a member */0;
    return nullptr;
  }

  clang::SourceLocation Loc = D->Def->getLocation();
  // clang::SourceLocation LocEnd = D->getEndOfDecl();
  clang::DeclarationName DN = D->Id;
  clang::InClassInitStyle InitStyle = clang::InClassInitStyle::ICIS_NoInit;
  if (D->hasInitializer())
    InitStyle = clang::InClassInitStyle::ICIS_ListInit;

  // TODO: implement static
  // bool DeclIsStatic = false;
  // if (isStaticMember(SemaRef, D, DeclIsStatic)) {
  //   return nullptr;
  // }
  clang::Decl *Field = nullptr;
  // if (DeclIsStatic) {
  //   // In this case we are creating a static member variable.
  //   clang::VarDecl *VDecl= clang::VarDecl::Create(Context.CxxAST, Owner, Loc,
  //                                                 LocEnd, D->getId(),
  //                                                 TInfo->getType(), TInfo,
  //                                                 clang::SC_Static);
  //   VDecl->setAccess(clang::AS_public);
  //   Field = VDecl;
  // } else {
    bool Mutable = false;
    // TODO: implement Mutability
    // if (isMutable(SemaRef, D, Mutable))
    //   return nullptr;
    // We are create field within a class.
    Field = SemaRef.getCxxSema().CheckFieldDecl(DN, TInfo->getType(),
                                                TInfo, /*RecordDecl=*/Owner,
                                                Loc, Mutable,
                                                /*BitWidth=*/nullptr, InitStyle,
                                                Loc, clang::AS_public, nullptr);
  // }
  Owner->addDecl(Field);
  D->setCxx(SemaRef, Field);
  // SemaRef.setDeclForDeclaration(D, Field);
  D->CurrentPhase = Phase::Typing;
  // elaborateAttributes(D);
  return Field;
}

// Type elaboration
//
// TODO: Can we combine this with the creating the declarator? It would save
// a pass over the AST. We could store the type directly in the declarator
// node (which we might do anyway), along with intermediate structures
// created to manage the declaration.

/// Return the type of entity declared by Dcl and establish any semantic
/// state needed to process the declaration and its initializer.
clang::Expr *Elaborator::elaborateDeclarator(const Declarator *Dcl) {
  switch (Dcl->getKind()) {
  case Declarator::Type:
    return elaborateTypeDeclarator(Dcl);
  case Declarator::Pointer:
    return elaboratePointerDeclarator(Dcl);
  case Declarator::Array:
    return elaborateArrayDeclarator(Dcl);
  case Declarator::Function:
    return elaborateFunctionDeclarator(Dcl);
  case Declarator::Template:
    return elaborateTemplateDeclarator(Dcl);
  case Declarator::Class:
    return elaborateClassDeclarator(Dcl);
  case Declarator::ImplicitType:
    return elaborateImplicitTypeDeclarator(Dcl);
  }
  llvm_unreachable("Unhandled kind of declarator.");
}

/// Elaborate declarations of the form 'T' as an expression.
clang::Expr *Elaborator::elaborateTypeDeclarator(const Declarator *Dcl) {
  clang::Expr *E = elaborateExpression(Dcl->getInfo());
  if (!E)
    return nullptr;
  clang::QualType T = E->getType();
  if (!T->isKindType()) {
    Error(Dcl->getLocation(), "invalid type");
    return nullptr;
  }
  return E;
}

/// Elaborate declarations of the form '^E'.
clang::Expr *Elaborator::elaboratePointerDeclarator(const Declarator *Dcl) {
  clang::Expr *E = elaborateDeclarator(Dcl->getNext());
  if (!E)
    return nullptr;

  // If this apears within a declarator then it must be a type.
  auto TInfo = SemaRef.getTypeSourceInfoFromExpr(E, E->getExprLoc());
  if (!TInfo)
    return nullptr;
  clang::QualType RetType = getCxxContext().getPointerType(TInfo->getType());
  return SemaRef.buildTypeExpr(RetType, Dcl->getLocation());
}

/// Elaborate declarations of the form '[E] T'.
clang::Expr *Elaborator::elaborateArrayDeclarator(const Declarator *Dcl) {
  llvm_unreachable("Not implemented");
}

/// Elaborate declarations of the form '(parms) T'.
/// This returns a type expression of the form `(parms) -> T`.
clang::Expr *Elaborator::elaborateFunctionDeclarator(const Declarator *Dcl) {
  llvm_unreachable("Not implemented yet");
}

clang::Expr *Elaborator::elaborateClassDeclarator(const Declarator *Dcl) {
  llvm_unreachable("Class Declaration not implemented.");
}

/// Elaborate declarations of the form '[parms] T'.
clang::Expr *Elaborator::elaborateTemplateDeclarator(const Declarator *Dcl) {
  llvm_unreachable("Not implemented");
}

clang::Expr *Elaborator::elaborateImplicitTypeDeclarator(const Declarator *Dcl) {
  clang::QualType Ty = getCxxContext().getAutoDeductType();
  return SemaRef.buildTypeExpr(Ty, clang::SourceLocation());
}

clang::Decl *Elaborator::identifyDeclsInClassBody(Declaration *D,
                                                  clang::CXXRecordDecl *R) {
  if(!D->hasInitializer()) {
    // FIXME: Handle forward declarations here? I think.
    llvm_unreachable("Type forward declarations are not implemented yet.");
    return nullptr;
  }

  // auto const* MacroRoot = dyn_cast<MacroSyntax>(D->Init);
  // assert(MacroRoot && "Invalid AST structure.");
  // auto const* BodyArray = MacroRoot->getBlock();
  D->CurrentPhase = Phase::Typing;

  // for (auto const* ChildDecl : BodyArray->children()) {
  for (const Syntax *SS : cast<SeqSyntax>(D->getInitializer())->children())
    identifyDeclaration(SS);
  return D->getCxx();
}

// Expression elaboration
clang::Expr *Elaborator::elaborateExpression(const Syntax *S) {
  return doElaborateExpression(S);
}

clang::Expr *Elaborator::elaborateConstantExpression(const Syntax *S) {
  clang::EnterExpressionEvaluationContext ConstantEvaluated(getCxxSema(),
                   clang::Sema::ExpressionEvaluationContext::ConstantEvaluated);
  Sema::DeepElaborationModeRAII ElabMode(SemaRef, true);
  clang::Expr *Res = doElaborateExpression(S);
  if (!Res)
    return Res;

  // This attempts to make sure that all referenced functions are actually
  // in scope, and completely elaborated.

  // TODO: I may need to re-implement the constant expression triggering
  // elaboration from gold.
  // SemaRef.elaborateConstexpr(Res);

  auto ConstExpr = SemaRef.getCxxSema().ActOnConstantExpression(Res);
  if (ConstExpr.isInvalid())
    return nullptr;
  return ConstExpr.get();
}

clang::Expr *Elaborator::doElaborateExpression(const Syntax *S) {
  assert(S && "invalid expression");
  switch (S->getKind()) {
  case Syntax::Literal:
    return elaborateLiteralExpression(cast<LiteralSyntax>(S));
  case Syntax::Identifier:
    return elaborateIdentifierExpression(cast<IdentifierSyntax>(S));
  case Syntax::List:
    return elaborateListExpression(cast<ListSyntax>(S));
  case Syntax::Seq:
    return elaborateSeqExpression(cast<SeqSyntax>(S));
  case Syntax::Unary:
    return elaborateUnaryExpression(cast<UnarySyntax>(S));
  case Syntax::Binary:
    return elaborateBinaryExpression(cast<BinarySyntax>(S));
  case Syntax::Error:
    Error(S->getLocation(), "failed parse");
    return nullptr;
  default:
    break;
  }
  S->dump();
  llvm_unreachable("Unexpected syntax tree");
}



static bool alwaysFitsInto64Bits(unsigned Radix, unsigned NumDigits) {
  switch (Radix) {
  case 2:
    return NumDigits <= 64;
  case 8:
    return NumDigits <= 64 / 3; // Digits are groups of 3 bits.
  case 10:
    return NumDigits <= 19; // floor(log10(2^64))
  case 16:
    return NumDigits <= 64 / 4; // Digits are groups of 4 bits.
  default:
    llvm_unreachable("impossible Radix");
  }
}

static bool checkOverflow(unsigned Radix, llvm::StringRef Literal,
                          llvm::APInt &Val) {
  const unsigned NumDigits = Literal.size();

  auto isDigitSeparator = [](char C) -> bool {
    return C == '\'';
  };

  if (alwaysFitsInto64Bits(Radix, NumDigits)) {
    uint64_t N = 0;
    for (const char *Ptr = Literal.begin(); Ptr != Literal.end(); ++Ptr)
      if (!isDigitSeparator(*Ptr))
        N = N * Radix + llvm::hexDigitValue(*Ptr);

    // This will truncate the value to Val's input width. Simply check
    // for overflow by comparing.
    Val = N;
    return Val.getZExtValue() != N;
  }

  Val = 0;
  const char *Ptr = Literal.begin();

  llvm::APInt RadixVal(Val.getBitWidth(), Radix);
  llvm::APInt CharVal(Val.getBitWidth(), 0);
  llvm::APInt OldVal = Val;

  bool OverflowOccurred = false;
  while (Ptr < Literal.end()) {
    if (isDigitSeparator(*Ptr)) {
      ++Ptr;
      continue;
    }

    unsigned C = llvm::hexDigitValue(*Ptr++);

    // If this letter is out of bound for this radix, reject it.
    assert(C < Radix && "checkOverflow called with wrong radix");

    CharVal = C;

    // Add the digit to the value in the appropriate radix.  If adding in digits
    // made the value smaller, then this overflowed.
    OldVal = Val;

    // Multiply by radix, did overflow occur on the multiply?
    Val *= RadixVal;
    OverflowOccurred |= Val.udiv(RadixVal) != OldVal;

    // Add value, did overflow occur on the value?
    //   (a + b) ult b  <=> overflow
    Val += CharVal;
    OverflowOccurred |= Val.ult(CharVal);
  }
  return OverflowOccurred;
}

static clang::IntegerLiteral *
createIntegerLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                     const LiteralSyntax *S, std::size_t Base = 10) {
  unsigned Width = S->Suffix.BitWidth;
  bool Signed = S->Suffix.IsSigned;

  // In case we didn't set either flag, this is signed by default.
  if (!Signed && !S->Suffix.IsUnsigned)
    Signed = true;

  unsigned TargetIntWidth = CxxAST.getTargetInfo().getIntWidth();
  if (!Width)
    Width = TargetIntWidth;

  clang::QualType IntTy = CxxAST.getIntTypeForBitwidth(Width, Signed);
  if (IntTy.isNull()) {
    if (Width <= TargetIntWidth)
      IntTy = Signed ? CxxAST.IntTy : CxxAST.UnsignedIntTy;
    else if (Width <= CxxAST.getTargetInfo().getLongWidth())
      IntTy = Signed ? CxxAST.LongTy : CxxAST.UnsignedLongTy;
    else
      IntTy = Signed ? CxxAST.LongLongTy : CxxAST.UnsignedLongLongTy;
  }

  if (Width != CxxAST.getIntWidth(IntTy)) {
    clang::SourceLocation Loc = S->getLocation();
    SemaRef.getCxxSema().Diags.Report(Loc,
      clang::diag::err_integer_bitwidth_mismatch)
      << IntTy << Width << CxxAST.getIntWidth(IntTy);
    return nullptr;
  }

  // skip over any [0.] prefix
  std::string Spelling = Base == 10 ? S->getSpelling().str() :
    S->getSpelling().substr(2).str();

  auto It = std::find(Spelling.begin(), Spelling.end(), '\'');
  while(It != std::end(Spelling)) {
    Spelling.erase(It);
    It = std::find(Spelling.begin(), Spelling.end(), '\'');
  }

  llvm::APInt Value(Width, Spelling, Base);
  Value = Value.zextOrTrunc(Width);

  if (checkOverflow(Base, Spelling, Value)) {
    SemaRef.getCxxSema().Diags.Report(S->getLocation(),
                                     clang::diag::err_integer_literal_too_large)
      << /* Unsigned */ 1;
    return nullptr;
  }

  return clang::IntegerLiteral::Create(CxxAST, Value, IntTy, S->getLocation());
}

static clang::FloatingLiteral *
createFloatLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                   const LiteralSyntax *S) {
  // If we don't have a specified type, just create a default float.
  clang::QualType FloatType = CxxAST.FloatTy;
  if (S->Suffix.IsDouble)
    FloatType = CxxAST.DoubleTy;
  else if (S->Suffix.IsHalf)
    FloatType = CxxAST.Float16Ty;
  else if (S->Suffix.IsQuarter) {
    unsigned DiagID =
      SemaRef.getCxxSema().Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,
                                    "minifloats not yet supported by Clang");
    SemaRef.getCxxSema().Diags.Report(S->getLocation(), DiagID);
    return nullptr;
  }

  const llvm::fltSemantics &Format = CxxAST.getFloatTypeSemantics(FloatType);
  using llvm::APFloat;
  APFloat Val = llvm::APFloat(Format);

  std::string Spelling = S->getSpelling().str();
  auto It = std::find(Spelling.begin(), Spelling.end(), '\'');
  while(It != std::end(Spelling)) {
    Spelling.erase(It);
    It = std::find(Spelling.begin(), Spelling.end(), '\'');
  }

  auto StatusOrErr =
    Val.convertFromString(Spelling, APFloat::rmNearestTiesToEven);
  assert(StatusOrErr && "Invalid floating point representation");
  return clang::FloatingLiteral::Create(CxxAST, Val, /*Exact=*/true,
                                        FloatType, S->getLocation());
}

static clang::FloatingLiteral *
createExponentLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                      const LiteralSyntax *S, clang::SourceLocation Loc) {
  std::string Spelling = S->getSpelling().str();
  assert((Spelling.find_first_of("E") != std::string::npos ||
         Spelling.find_first_of("e") != std::string::npos) &&
         "non-exponent");
  auto It = std::find(Spelling.begin(), Spelling.end(), '\'');
  while(It != std::end(Spelling)) {
    Spelling.erase(It);
    It = std::find(Spelling.begin(), Spelling.end(), '\'');
  }

  const llvm::fltSemantics &Format =
    CxxAST.getFloatTypeSemantics(CxxAST.DoubleTy);
  llvm::APFloat Val(Format);
  auto StatusOrErr =
    Val.convertFromString(Spelling, llvm::APFloat::rmNearestTiesToEven);
  assert(StatusOrErr && "invalid floating point representation");
  if (llvm::errorToBool(StatusOrErr.takeError()))
    return nullptr;

  llvm::APFloat::opStatus Result = *StatusOrErr;
  if ((Result & llvm::APFloat::opOverflow) ||
      ((Result & llvm::APFloat::opUnderflow) && Val.isZero())) {
    unsigned Diagnostic;
    llvm::SmallString<20> Buffer;
    if (Result & llvm::APFloat::opOverflow) {
      Diagnostic = clang::diag::warn_float_overflow;
      llvm::APFloat::getLargest(Format).toString(Buffer);
    } else {
      Diagnostic = clang::diag::warn_float_underflow;
      llvm::APFloat::getSmallest(Format).toString(Buffer);
    }

    SemaRef.getCxxSema().Diags.Report(Loc, Diagnostic)
      << CxxAST.DoubleTy
      << llvm::StringRef(Buffer.data(), Buffer.size());
  }

  clang::QualType FloatType = CxxAST.FloatTy;
  if (S->Suffix.IsDouble)
    FloatType = CxxAST.DoubleTy;

  bool isExact = (Result == llvm::APFloat::opOK);
  return clang::FloatingLiteral::Create(CxxAST, Val, isExact, FloatType, Loc);
}

/// This was copied from clang/lib/lex/LiteralSupport.cpp:91, and modified.
static unsigned processCharEscape(Sema &SemaRef, clang::SourceLocation Loc,
    const char *&ThisTokBuf, const char *ThisTokEnd,
    bool &HadError, unsigned CharWidth) {

  // Skip the '\' char.
  ++ThisTokBuf;

  // We know that this character can't be off the end of the buffer, because
  // that would have been \", which would not have been the end of string.
  unsigned ResultChar = *ThisTokBuf++;

  switch (ResultChar) {
  // These map to themselves.
  case '\\': case '\'': case '"': case '?': break;

    // These have fixed mappings.
  case 'a':
    ResultChar = 7;
    break;
  case 'b':
    ResultChar = 8;
    break;
  case 'e':
    SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_nonstandard_escape)
        << "e";
    ResultChar = 27;
    break;
  case 'E':
    SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_nonstandard_escape)
        << "E";
    ResultChar = 27;
    break;
  case 'f':
    ResultChar = 12;
    break;
  case 'n':
    ResultChar = 10;
    break;
  case 'r':
    ResultChar = 13;
    break;
  case 't':
    ResultChar = 9;
    break;
  case 'v':
    ResultChar = 11;
    break;
  case 'x': { // Hex escape.
    ResultChar = 0;
    if (ThisTokBuf == ThisTokEnd || !clang::isHexDigit(*ThisTokBuf)) {
      SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::err_hex_escape_no_digits)
          << "x";
      HadError = true;
      break;
    }

    // Hex escapes are a maximal series of hex digits.
    bool Overflow = false;
    for (; ThisTokBuf != ThisTokEnd; ++ThisTokBuf) {
      int CharVal = llvm::hexDigitValue(ThisTokBuf[0]);
      if (CharVal == -1) break;
      // About to shift out a digit?
      if (ResultChar & 0xF0000000)
        Overflow = true;
      ResultChar <<= 4;
      ResultChar |= CharVal;
    }

    // See if any bits will be truncated when evaluated as a character.
    if (CharWidth != 32 && (ResultChar >> CharWidth) != 0) {
      Overflow = true;
      ResultChar &= ~0U >> (32-CharWidth);
    }

    // Check for overflow.
    if (Overflow)   // Too many digits to fit in
      SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::err_escape_too_large)
          << 0;
    break;
  }
  case '0': case '1': case '2': case '3':
  case '4': case '5': case '6': case '7': {
    // Octal escapes.
    --ThisTokBuf;
    ResultChar = 0;

    // Octal escapes are a series of octal digits with maximum length 3.
    // "\0123" is a two digit sequence equal to "\012" "3".
    unsigned NumDigits = 0;
    do {
      ResultChar <<= 3;
      ResultChar |= *ThisTokBuf++ - '0';
      ++NumDigits;
    } while (ThisTokBuf != ThisTokEnd && NumDigits < 3 &&
             ThisTokBuf[0] >= '0' && ThisTokBuf[0] <= '7');

    // Check for overflow.  Reject '\777', but not L'\777'.
    if (CharWidth != 32 && (ResultChar >> CharWidth) != 0) {
      SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::err_escape_too_large)
          << 1;
      ResultChar &= ~0U >> (32-CharWidth);
    }
    break;
  }

    // Otherwise, these are not valid escapes.
  case '(': case '{': case '[': case '%':
    // GCC accepts these as extensions.  We warn about them as such though.
    // TODO: We need to determine if we need to suppor this or not.
    SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_nonstandard_escape)
        << std::string(1, ResultChar);
    break;
  default:

    if (clang::isPrintable(ResultChar))
      SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_unknown_escape)
          << std::string(1, ResultChar);
    else
      SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_unknown_escape)
          <<  "x" + llvm::utohexstr(ResultChar);
    break;
  }

  return ResultChar;
}

/// readCharacter attempts to read the next character in a literal value
/// if there's an error true is returned, and otherwise the result is false.
///
/// The Iter will be advanced to the position of the next character in the
/// string.
///
/// This function will indicate an error when Iter == End. It's important to
/// set test that value before the next call to this function.
static bool readCharacter(Sema &SemaRef, clang::SourceLocation Loc,
                          const char *&Iter, const char *End, unsigned &Value,
                          bool &Escape) {
  assert (Iter <= End && "Invalid character");

  // Process an escape sequence if we encounter one, otherwise do a simple
  // character literal read.
  if (*Iter == '\\') {
    Escape = true;
    bool DidError = false;
    Value = processCharEscape(SemaRef, Loc, Iter, End, DidError, 8u);
    return DidError;
  } else {
    Escape = false;
    Value = *Iter;
    ++Iter;
  }

  return false;
}

static clang::CharacterLiteral *
createCharLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                  Token T, clang::SourceLocation Loc) {
  auto Spelling = T.getSpelling();
  assert(Spelling[0] == '\'' && "atom is not a character");

  Spelling = Spelling.substr(1, Spelling.size());
  Spelling = Spelling.substr(0, Spelling.find_last_of('\''));
  if (Spelling.empty()) {
    SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_empty_character);
    return nullptr;
  }

  llvm::SmallString<16> CharBuffer;
  CharBuffer.append(Spelling.begin(), Spelling.end());
  unsigned Character = 0;
  bool EscapeSeq;
  const char *CharBegin = CharBuffer.data();
  const char *CharEnd = CharBuffer.data() + CharBuffer.size();
  if (readCharacter(SemaRef, Loc, CharBegin, CharEnd, Character, EscapeSeq)) {
    SemaRef.getCxxSema().Diags.Report(Loc, clang::diag::ext_unknown_escape)
      << CharBuffer.data();
    return nullptr;
  }

  // A multi-character character constant is actually valid, so we'll just
  // warn and move on.
  if (!EscapeSeq && Spelling.size() > 1) {
    unsigned DiagID =
      SemaRef.getCxxSema().Diags.getCustomDiagID(clang::DiagnosticsEngine::Warning,
                                    "multi-character character constant");
    SemaRef.getCxxSema().Diags.Report(Loc, DiagID);
  }

  return new (CxxAST) clang::CharacterLiteral(Character,
                                              clang::CharacterLiteral::UTF8,
                                              SemaRef.DefaultCharTy, Loc);
}

static clang::CharacterLiteral *
createUTF8Literal(clang::ASTContext &CxxAST, Sema &SemaRef,
                  Token T, clang::SourceLocation Loc) {
  std::string Spelling = T.getSpelling().str();
  Spelling = Spelling.substr(Spelling.find_first_not_of("0c"), Spelling.size());
  unsigned Value = (unsigned)std::stoi(Spelling, 0, 16);

  // FIXME: warn on overflow?

  return new (CxxAST)
    clang::CharacterLiteral(Value, clang::CharacterLiteral::UTF8,
                            CxxAST.Char8Ty, Loc);
}

static clang::CharacterLiteral *
createUnicodeLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                     Token T, clang::SourceLocation Loc) {
  std::string Spelling = T.getSpelling().str();
  Spelling = Spelling.substr(Spelling.find_first_not_of("0u"), Spelling.size());
  unsigned Value = (unsigned)std::stoi(Spelling, 0, 16);

  // FIXME: warn on overflow?

  clang::CharacterLiteral::CharacterKind CharKind;
  clang::QualType CharType;
  if (Value <= 0xFF) {
    CharKind = clang::CharacterLiteral::UTF8;
    CharType = CxxAST.Char8Ty;
  } else if (Value <= 0xFFFF) {
    CharKind = clang::CharacterLiteral::UTF16;
    CharType = CxxAST.Char16Ty;
  } else if (Value <= 0xFFFFFFFF) {
    CharKind = clang::CharacterLiteral::UTF32;
    CharType = CxxAST.Char32Ty;
  } else {
    return nullptr;
  }

  return new (CxxAST) clang::CharacterLiteral(Value, CharKind, CharType, Loc);
}

static clang::StringLiteral *
createStringLiteral(clang::ASTContext &CxxAST, Sema &SemaRef,
                    Token T, const Syntax *StrNode) {
  auto Str = T.getSpelling();
  clang::Token CTok;
  CTok.startToken();
  CTok.setKind(clang::tok::utf8_string_literal);
  CTok.setLocation(StrNode->getLocation());
  CTok.setLength(Str.size());
  llvm::SmallVector<clang::Token, 1> StrTokens;
  StrTokens.push_back(CTok);
  clang::StringLiteralParser StrParser(StrTokens, CxxAST.getSourceManager(),
                                       CxxAST.getLangOpts(),
                                       CxxAST.getTargetInfo(),
                                       &SemaRef.getCxxSema().Diags);

  clang::QualType StrTy = CxxAST.getStringLiteralArrayType(
                          SemaRef.DefaultCharTy, StrParser.GetNumStringChars());
  auto EncodingKind = clang::StringLiteral::Ascii;
  // if (SemaRef.insideAttributeExpr()) {
  //   EncodingKind = ;
  // }
  return clang::StringLiteral::Create(CxxAST, StrParser.GetString(),
                                      EncodingKind,
                                      false, StrTy, StrNode->getLocation());
}

static clang::CXXBoolLiteralExpr *
createBoolLiteral(clang::ASTContext &CxxAST, Token T,
                  clang::SourceLocation Loc) {
  return new (CxxAST) clang::CXXBoolLiteralExpr(T.hasKind(tok::TrueKeyword),
                                                CxxAST.BoolTy, Loc);
}

static clang::CXXNullPtrLiteralExpr *
createNullLiteral(clang::ASTContext &CxxAST, clang::SourceLocation Loc) {
  return new (CxxAST) clang::CXXNullPtrLiteralExpr(CxxAST.NullPtrTy, Loc);
}

clang::Expr *Elaborator::elaborateLiteralExpression(const LiteralSyntax *S) {
  // Other things we need in the future.
  // DecimalExponent
  // HexadecimalCharacter
  // UnicodeCharacter
  const Token& Tok = S->getToken();
  switch (Tok.getKind()) {
  case tok::DecimalInteger:
    return createIntegerLiteral(getCxxContext(), SemaRef, S);
  case tok::DecimalFloat:
    return createFloatLiteral(getCxxContext(), SemaRef, S);
  case tok::BinaryInteger:
    return createIntegerLiteral(getCxxContext(), SemaRef, S, 2);
  case tok::HexadecimalInteger:
    return createIntegerLiteral(getCxxContext(), SemaRef, S, /*Base=*/16);
  case tok::HexadecimalFloat:
    llvm_unreachable("Hexadecimal float not implemented");
    break;
  case tok::Character:
    return createCharLiteral(getCxxContext(), SemaRef, Tok, S->getLocation());
  case tok::String:
    return createStringLiteral(getCxxContext(), SemaRef, Tok, S);
  case tok::TrueKeyword:
  case tok::FalseKeyword:
    return createBoolLiteral(getCxxContext(), Tok, S->getLocation());
  case tok::NullKeyword:
    return createNullLiteral(getCxxContext(), S->getLocation());
  case tok::VoidKeyword:
    return SemaRef.buildTypeExpr(getCxxContext().VoidTy, Tok.getLocation());
  case tok::BoolKeyword:
    return SemaRef.buildTypeExpr(getCxxContext().BoolTy, Tok.getLocation());
  case tok::ByteKeyword:
    return SemaRef.buildTypeExpr(getCxxContext().UnsignedCharTy,
                                 Tok.getLocation());
  case tok::CharacterKeyword:
    return SemaRef.buildTypeExpr(getCxxContext().CharTy,
                                 Tok.getLocation());
  case tok::IntegerKeyword:
    // FIXME: Support arbitrary length integer types via the lexer.
    return SemaRef.buildTypeExpr(getCxxContext().IntTy,
                                 Tok.getLocation());
  case tok::FloatKeyword:
    // FIXME: Support arbitrary length floating point types vie the lexer.
    return SemaRef.buildTypeExpr(getCxxContext().DoubleTy,
                                 Tok.getLocation());
  case tok::TypeKeyword:
    return SemaRef.buildTypeExpr(getCxxContext().CppxKindTy,
                                 Tok.getLocation());

  default:
    break;
  }

  llvm_unreachable("Not implemented");
}

void Elaborator::elaborateDefinition(const Syntax *S) {
  auto Decl = SemaRef.getCurrentScope()->findDecl(S);
  if (!Decl)
    return;
  // Attempt to process the current declaration again.
  Sema::DeclarationElaborationRAII DeclElab(SemaRef, Decl);
  elaborateDefinitionInitialization(Decl);
}

void Elaborator::elaborateDefinitionInitialization(Declaration *D) {
  // If the current phase isn't typing then bail.
  if (phaseOf(D) != Phase::Typing)
    return;
  if (D->isFieldDecl())
    return elaborateFieldInit(D);
  if (D->isVariableDecl())
    return elaborateVarDef(D);
  if (D->isFunctionDecl())
    return elaborateFunctionDef(D);

  llvm_unreachable("Elaboration for this kind of declaration isn't "
                   "implemented yet.");
}

void Elaborator::elaborateVarDef(Declaration *D) {
  D->CurrentPhase = Phase::Initialization;
  if (!D->getCxx())
    return;


  // If this isn't early elaboration then we have to actually track it.
  // if (!IsEarly)
  //   ElabTracker.init(D);

  // Sema::OptionalInitScope<Sema::ResumeScopeRAII> OptResumeScope(SemaRef);
  // clang::Expr *InitExpr = nullptr;
  // clang::VarDecl *VD = nullptr;
  // Sema::DeclInitializationScope ClangInitScope(SemaRef, D);
  // bool NeedsConstEvaluation = false;
  // if (D->defines<clang::VarTemplateDecl>()) {
  //   if (SemaRef.checkForRedefinition<clang::VarTemplateDecl>(D))
  //     return;

  //   // We need to attempt to re-enter the template context for this variable.
  //   OptResumeScope.Init(D->SavedScope, D->Op);
  //   clang::VarTemplateDecl *VTD = cast<clang::VarTemplateDecl>(D->Cxx);
  //   VD = VTD->getTemplatedDecl();
  // } else {
  //   if (SemaRef.checkForRedefinition<clang::VarDecl>(D))
  //     return;
  //   VD = cast<clang::VarDecl>(D->Cxx);
  // }

  // if (VD->isConstexpr())
  //   NeedsConstEvaluation = true;
  clang::VarDecl *VD = cast<clang::VarDecl>(D->getCxx());
  const DefSyntax *Def = D->asDef();
  if (!Def)
    return;
  if (!Def->hasInitializer()) {
    // if (isa<clang::ParmVarDecl>(VD))
    //   return;
    // FIXME: We probably want to synthesize some kind of initializer here.
    // Not quite sure how we want to do this.
    //
    // FIXME: What if D has type auto? Surely this is an error. For example:
    //
    //    x : auto
    //
    // declares an undeduced-type variable with no initializer. Presumably
    // this should be an error.

    // This handles implcit initialization/constructor calls for variables
    // that don't have a = sign on first use, but have a type.
    // That includes complex types.
    getCxxSema().ActOnUninitializedDecl(VD);
    getCxxSema().FinalizeDeclaration(VD);
    return;
  }
  // if (D->defines<clang::VarTemplateDecl>()) {
  //   // I may need to revisit this in the furture becaus this might not be
  //   // the right thing to do in this case.
  //   VD->setInit(InitExpr);
  // } else {

  // if (D->isDeclaredWithinClass() && !VD->isInlineSpecified()
  //     && (!VD->getType().isConstant(Context.CxxAST) && !VD->isConstexpr())) {
  //   SemaRef.Diags.Report(D->IdDcl->getLoc(),
  //                       clang::diag::err_in_class_initializer_non_const);
  //   return;
  // }
  auto InitExpr = elaborateExpression(Def->getInitializer());
  if (!InitExpr)
    return;
  // Update the initializer.
  getCxxSema().AddInitializerToDecl(VD, InitExpr, /*DirectInit=*/true);
}

void Elaborator::elaborateFieldInit(Declaration *D) {
  assert(D && "Missing Declaration.");
  if (!D->hasInitializer())
    return;
  D->CurrentPhase = Phase::Initialization;
  getCxxSema().ActOnStartCXXInClassMemberInitializer();

  using EEC = clang::Sema::ExpressionEvaluationContext;
  clang::EnterExpressionEvaluationContext EEContext(getCxxSema(),
                                                    EEC::PotentiallyEvaluated,
                                                    D->getCxx());
  clang::Expr *InitExpr = elaborateExpression(D->getInitializer());
  if (!InitExpr) {
    return;
  }

  getCxxSema().ActOnFinishCXXInClassMemberInitializer(D->getCxx(),
                                                      D->Def->getLocation(),
                                                      InitExpr);
}

void Elaborator::elaborateFunctionDef(Declaration *D) {
  D->CurrentPhase = Phase::Initialization;

  if (!D->getCxx())
    return;
  if (!D->Init)
    return;

  // We saved the parameter scope while elaborating this function's type,
  // so push it on before we enter the function scope.
  assert(D->Decl->declaresFunction());
  Scope *ParamScope = D->Decl->DeclInfo.ParamScope;
  ResumeScopeRAII FnDclScope(SemaRef, ParamScope, ParamScope->getTerm());

  Declaration *CurrentDeclaration = SemaRef.getCurrentDecl();
  // Entering clang scope. for function definition.
  SemaRef.enterClangScope(clang::Scope::FnScope |clang::Scope::DeclScope |
                          clang::Scope::CompoundStmtScope);
  clang::Decl *FuncDecl =
    SemaRef.getCxxSema().ActOnStartOfFunctionDef(SemaRef.getCurClangScope(),
                                                 D->getCxx());


  Sema::ScopeRAII FnScope(SemaRef, Scope::Function, D->Init);
  SemaRef.setCurrentDecl(D);

  clang::Stmt *Body = elaborateSeq(cast<SeqSyntax>(D->Init));
  SemaRef.setClangDeclContext(cast<clang::FunctionDecl>(D->getCxx()));
  SemaRef.getCxxSema().ActOnFinishFunctionBody(FuncDecl, Body);

  // Return the current decl to whatever it was before.
  SemaRef.setCurrentDecl(CurrentDeclaration);
}

/// This creates the correct expression in order to correctly reference
/// a type, variable, single function, or any thing else that may
/// be returned from by the look up.
static clang::Expr *BuildReferenceToDecl(Sema &SemaRef,
                                         clang::SourceLocation Loc,
                                         clang::LookupResult &R,
                                         bool IsKnownOverload = false);

clang::Expr *Elaborator::elaborateIdentifierExpression(const IdentifierSyntax *S) {
  // Check for builtin types.
  auto BuiltinMapIter = SemaRef.BuiltinTypes.find(S->getSpelling());
  if (BuiltinMapIter != SemaRef.BuiltinTypes.end())
    return SemaRef.buildTypeExpr(BuiltinMapIter->second, S->getLocation());

  // llvm::outs() << "ELABORATING NON-TYPE EXPR\n";
  // Doing variable lookup.
  clang::IdentifierInfo *II = &getCxxContext().Idents.get(S->getSpelling());
  clang::LookupResult R(getCxxSema(), {{II}, S->getLocation()},
                        clang::Sema::LookupOrdinaryName);
  SemaRef.lookupUnqualifiedName(R);
  R.resolveKind();
  switch (R.getResultKind()) {
  case clang::LookupResult::FoundOverloaded: {
    llvm_unreachable("Overloaded functions not implemented yet.");
  }
  case clang::LookupResult::Found:
    return BuildReferenceToDecl(SemaRef, S->getLocation(), R, false);
  case clang::LookupResult::NotFoundInCurrentInstantiation:
  case clang::LookupResult::NotFound: {
    getCxxSema().Diags.Report(S->getLocation(),
                              clang::diag::err_undeclared_var_use)
                              << S->getSpelling();
    return nullptr;
  }
  case clang::LookupResult::FoundUnresolvedValue:
    // FIXME: I need to figure out when this can occur, then create
    // that situiation wihtin a test and build appropriate error message.
    // I suspect that this may have something to do with variable template
    // declarations.
    llvm_unreachable("Not sure how handle unresolved values.");
  case clang::LookupResult::Ambiguous:
    getCxxSema().DiagnoseAmbiguousLookup(R);
    return nullptr;
  }

  return nullptr;
}

clang::Expr *BuildReferenceToDecl(Sema &SemaRef,
                                  clang::SourceLocation Loc,
                                  clang::LookupResult &R,
                                  bool IsKnownOverload) {
  std::string Name = R.getLookupName().getAsString();
  if (IsKnownOverload) {
    llvm_unreachable("We haven't implemented overload references yet.");
  }
  // assert(FoundDecl && "Incorrectly set found declaration.");
  if (clang::ValueDecl *VD = R.getAsSingle<clang::ValueDecl>()) {
    // clang::QualType FoundTy = VD->getType();
    // If the user annotated the DeclRefExpr with an incorrect type.
    // if (!Ty.isNull() && Ty != FoundTy) {
    //   SemaRef.getCxxSema().Diags.Report(Loc,
    //     clang::diag::err_type_annotation_mismatch) << FoundTy << Ty;
    //   return nullptr;
    // }

    if (isa<clang::FieldDecl>(VD)) {
      // Building this access.
      // clang::FieldDecl* Field = cast<clang::FieldDecl>(VD);
      // clang::RecordDecl* RD = Field->getParent();
      // clang::QualType ThisTy(RD->getTypeForDecl(), 0);
      // clang::QualType ThisPtrTy = SemaRef.getContext().CxxAST.getPointerType(
      //                                                                 ThisTy);
      // clang::Expr* This = SemaRef.getCxxSema().BuildCXXThisExpr(Loc,
      //                                                           ThisPtrTy,
      //                                                           true);

      // clang::DeclAccessPair FoundDecl = clang::DeclAccessPair::make(Field,
      //                                                     Field->getAccess());
      // clang::CXXScopeSpec SS;
      // clang::ExprResult MemberExpr
      //     = SemaRef.getCxxSema().BuildFieldReferenceExpr(This, true,
      //                                                 clang::SourceLocation(),
      //                                                     SS, Field, FoundDecl,
      //                                                     DNI);
      // clang::Expr *Ret = MemberExpr.get();
      // if (!Ret) {
      //   SemaRef.Diags.Report(Loc, clang::diag::err_no_member)
      //       << Field << ThisTy;
      // }
      // ExprMarker(Context.CxxAST, SemaRef).Visit(Ret);
      // return Ret;
      llvm_unreachable("Reference to a Field decl not implemented yet.");
    }
    // Need to check if the result is a CXXMethodDecl because that's a
    // ValueDecl.
    if(isa<clang::CXXMethodDecl>(VD)) {
      // clang::CXXScopeSpec SS;
      // clang::SourceLocation Loc;
      // // This may need to change into a different type of function call
      // // base on given arguments, because this could be an issue.
      // return SemaRef.getCxxSema().BuildPossibleImplicitMemberExpr(SS, Loc, R,
      //                                                             nullptr,
      //                                       SemaRef.getCurClangScope()).get();
      llvm_unreachable("Reference to a CXX Method decl not implemented yet.");
    }

    if(isa<clang::FunctionDecl>(VD)) {
      // // Correctly rebuilding the declaration name info.
      // DNI = SemaRef.rebuildDeclarationNameInfo(DNI);
      // return clang::UnresolvedLookupExpr::Create(Context.CxxAST,
      //                                             R.getNamingClass(),
      //                                         clang::NestedNameSpecifierLoc(),
      //                                             DNI,
      //                                             /*ADL=*/true, true,
      //                                             R.begin(), R.end());
      llvm_unreachable("Reference to a function decl not implemented yet.");
    }
    // Simply assuming that this is a variable declaration.
    clang::QualType ResultType = VD->getType();
    if (ResultType.getTypePtr()->isReferenceType())
      ResultType = ResultType.getTypePtr()->getPointeeType();

    clang::ExprValueKind ValueKind =
      SemaRef.getCxxSema().getValueKindForDeclReference(ResultType,
                                                        VD, Loc);
    clang::DeclRefExpr *DRE =
      SemaRef.getCxxSema().BuildDeclRefExpr(VD, ResultType, ValueKind,
                                            R.getLookupNameInfo(),
                                            clang::NestedNameSpecifierLoc(),
                                            VD, clang::SourceLocation(),
                                            nullptr);
    return DRE;
  }

  // Processing the case when the returned result is a type.
  if (const clang::TagDecl *TD = R.getAsSingle<clang::TagDecl>())
    return SemaRef.buildTypeExprFromTypeDecl(TD, Loc);

  if (clang::ClassTemplateDecl *CTD
                                = R.getAsSingle<clang::ClassTemplateDecl>())
    llvm_unreachable("Reference to class template decl not implemented yet.");
    // return SemaRef.buildTemplateType(CTD, Loc);

  if (auto *NS = R.getAsSingle<clang::CppxNamespaceDecl>())
    llvm_unreachable("Reference to cppx namespace decl not implemented yet.");
    // return SemaRef.buildNSDeclRef(NS, Loc);


  if (auto *TD = R.getAsSingle<clang::TypeDecl>())
    llvm_unreachable("Reference to type decl not implemented yet.");
    // return SemaRef.buildTypeExprFromTypeDecl(TD, Loc);

  if (auto *TD = R.getAsSingle<clang::TemplateDecl>())
    // return SemaRef.buildTemplateType(TD, Loc);
    llvm_unreachable("Reference to template decl not implemented yet.");

  SemaRef.getCxxSema().Diags.Report(Loc,
                              clang::diag::err_identifier_not_declared_in_scope)
                                   << Name;
  return nullptr;
}



clang::Expr *Elaborator::elaborateListExpression(const ListSyntax *S) {
  llvm_unreachable("Not implemented");
}

clang::Expr *Elaborator::elaborateSeqExpression(const SeqSyntax *S) {
  llvm_unreachable("Not implemented");
}

clang::Expr *Elaborator::elaborateUnaryExpression(const UnarySyntax *S) {
  auto Operand = elaborateExpression(S->getOperand());
  if (!Operand)
    return nullptr;
  clang::QualType Ty = Operand->getType();
  if (Ty->isTypeOfTypes()) {
    if (S->getOperator().hasKind(tok::Caret)) {
      // FIXME: how can we assert that this is a declarator?
      // If this apears within a declarator then it must be a type.
      auto TInfo = SemaRef.getTypeSourceInfoFromExpr(Operand,
                                                     Operand->getExprLoc());
      if (!TInfo)
        return nullptr;

      clang::QualType RetType = getCxxContext().getPointerType(TInfo->getType());
      return SemaRef.buildTypeExpr(RetType, S->getLocation());
    }
    getCxxSema().Diags.Report(S->getOperand()->getLocation(),
                              clang::diag::err_invalid_type_operand)
                              << 0/*unary*/;
    return nullptr;
  }

  if (S->getOperator().hasKind(tok::Caret)) {
    // llvm_unreachable("Make an error message for this.");
    getCxxSema().Diags.Report(S->getLocation(),
                              clang::diag::err_prefix_caret_on_non_type);
    return nullptr;
  }

  auto OpIter = SemaRef.UnaryOpMap.find(S->getOperatorSpelling());
  if (OpIter == SemaRef.UnaryOpMap.end()) {
    Error(S->getLocation(), "invalid unary operator");
    return nullptr;
  }
  auto Res = SemaRef.getCxxSema().BuildUnaryOp(
    /*scope*/nullptr, S->getLocation(), OpIter->second, Operand);
  return Res.get();
}

clang::Expr *Elaborator::elaborateBinaryExpression(const BinarySyntax *S) {
  if (S->isApplication()) {
    const Syntax *LHSSyntax = S->getLeftOperand();
    auto LS = dyn_cast<LiteralSyntax>(LHSSyntax);
    if (LS) {
      if (LS->getSpelling() == "integer")
        return elaborateIntegerMetaFunction(S);
      if (LS->getSpelling() == "real")
        return elaborateRealMetaFunction(S);
      if (LS->getSpelling() == "character")
        return elaborateCharacterMetaFunction(S);
    }
  }
  auto LHS = elaborateExpression(S->getLeftOperand());
  if (!LHS)
    return nullptr;
  if (S->isApplication())
    return elaborateApplyExpression(LHS, S);

  auto RHS = elaborateExpression(S->getRightOperand());
  if (!RHS)
    return nullptr;

  auto OpIter = SemaRef.BinOpMap.find(S->getOperatorSpelling());
  if (OpIter == SemaRef.BinOpMap.end()) {
    Error(S->getLocation(), "invalid binary operator");
    return nullptr;
  }
  clang::ExprResult Res = SemaRef.getCxxSema().BuildBinOp(/*Scope=*/nullptr,
                                                          S->getLocation(),
                                                          OpIter->second, LHS,
                                                          RHS);
  return Res.get();
}

clang::Stmt *Elaborator::elaborateSeq(const SeqSyntax *S) {
  SemaRef.getCxxSema().ActOnStartOfCompoundStmt(false);
  Sema::ScopeRAII BlockScope(SemaRef, Scope::Block, S);

  llvm::SmallVector<clang::Stmt *, 16> Results;
  clang::SourceLocation StartLoc = S->getBeginLocation();
  clang::SourceLocation EndLoc = S->getEndLocation();
  StartLoc = EndLoc = S->getLocation();
  for (const Syntax *Child : S->children()) {
    clang::Stmt *Statement = elaborateStatement(Child);
    if (!Statement)
      continue;
    Results.push_back(Statement);
  }

  clang::Stmt *Block = SemaRef.getCxxSema().ActOnCompoundStmt(StartLoc, EndLoc,
                                          Results, /*isStmtExpr=*/false).get();
  return Block;
}

clang::Stmt *Elaborator::elaborateStatement(const Syntax *S) {
  if (const UnarySyntax *U = dyn_cast<UnarySyntax>(S))
    return elaborateUnaryStmt(U);

  // TODO: elaborate by syntax type: i.e. atom, etc. See GoldStmtElaborator

  // If the statement kind is unknown then simply punt and
  // elaborate an expression.
  clang::Expr *E = elaborateExpression(S);
  if (E)
    return nullptr;
  auto CheckExpr = SemaRef.getCxxSema().CheckPlaceholderExpr(E);
  if (CheckExpr.isInvalid())
    return nullptr;
  auto ExprStmt =
    SemaRef.getCxxSema().ActOnExprStmt(CheckExpr.get(), /*discardedValue*/true);
  if (ExprStmt.isInvalid())
    return nullptr;

  return ExprStmt.get();
}

clang::Stmt *Elaborator::elaborateUnaryStmt(const UnarySyntax *S) {
  switch (S->getOperator().getKind()) {
  case tok::ReturnKeyword:
    return elaborateReturnStmt(S);

  default:
    break;
  } // switch (S->getOperator())->getKind()

  return elaborateUnaryExpression(S);
}

clang::Stmt *Elaborator::elaborateReturnStmt(const UnarySyntax *S) {
  clang::Expr *Val = nullptr;

  if (S->getOperand())
    // if this elaborates to null, we'll just let clang::Sema handle the error
    Val = elaborateExpression(S->getOperand());

  auto ReturnResult = SemaRef.getCxxSema().ActOnReturnStmt(
    S->getOperator().getLocation(), Val, SemaRef.getCurClangScope());

  return ReturnResult.get();
}

clang::Expr *Elaborator::elaborateApplyExpression(clang::Expr *LHS,
                                                  const BinarySyntax *S) {
  // TODO: I need to figure out and dispatch all of the different possible
  // situations that could occur here.
  // 1. Template instantiation
  // 2. Function Call - Needs verifications
  // 3. Array declaration - Needs verifications
  // 4. Template declarations - Needs verifications
  // 5. Block attached to something possibly? - Needs verifications
  S->dump();
  llvm_unreachable("apply expression Not implemented yet!?\n");
}

/// This function extracts the number of bytes argument from integer, character,
/// and real, and evaluates the integer within the constant expression in order
/// to make sure that it's a valid value.
/// @returns true in the event there was an error.
static bool handleBuiltInByteCountEval(Elaborator &Elab, const Syntax *BytesArg,
                                       const char *FnName,
                                       const char *ArgOneText,
                                       const char* ArgTwoErrorText,
                                       int64_t MaxBytesAllowed,
                                       int64_t &ByteCount) {
  auto reportInvalidUse = [&](clang::SourceLocation L, int MsgIdx = 0) -> bool {
    Elab.getCxxSema().Diags.Report(
      L, clang::diag::err_invalid_use_of_built_in_type_function)
      << FnName << ArgOneText << ArgTwoErrorText << MsgIdx;
    return true;
  };
  clang::SourceLocation BytesLoc = BytesArg->getLocation();
  auto ByteCountExpr = Elab.elaborateConstantExpression(BytesArg);
  if (!ByteCountExpr)
    return reportInvalidUse(BytesLoc);
  clang::Expr::EvalResult BCResult;
  clang::Expr::EvalContext EvalCtx(Elab.getCxxContext(),
                               Elab.getCxxSema().GetReflectionCallbackObj());
  if (ByteCountExpr->EvaluateAsConstantExpr(BCResult, EvalCtx)) {
    if (BCResult.Val.isInt()) {
      if (!BCResult.Val.getInt().isPowerOf2())
        return reportInvalidUse(BytesLoc, 1);

      // Max number of bytes allowed.
      ByteCount = BCResult.Val.getInt().getExtValue();
      if (ByteCount > MaxBytesAllowed)
        return reportInvalidUse(BytesLoc, 1);
      return false;
    } else
      return reportInvalidUse(BytesLoc, 2);
  } else
    return reportInvalidUse(BytesLoc, 3);
}

clang::Expr *Elaborator::elaborateIntegerMetaFunction(const BinarySyntax *S) {
  auto LHSSyntax = dyn_cast<LiteralSyntax>(S->getLeftOperand());
  clang::SourceLocation Loc = LHSSyntax->getLocation();
  auto RHSSyntax = S->getRightOperand();
  auto reportInvalidUse = [&](clang::SourceLocation L, int MsgIdx =0) -> clang::Expr * {
    getCxxSema().Diags.Report(L,
                         clang::diag::err_invalid_use_of_built_in_type_function)
                              << "integer" << "number-of-bytes"
                              << "signed-or-unsigned"
                              << MsgIdx;
    return nullptr;
  };
  if (auto RHSList = dyn_cast<ListSyntax>(RHSSyntax)) {
    if (RHSList->getNumChildren() != 2)
      return reportInvalidUse(RHSList->getLocation());

    if (!RHSList->getChild(0))
      return reportInvalidUse(Loc);
    int64_t ByteCount = 0;
    if(handleBuiltInByteCountEval(*this, RHSList->getChild(0), "integer",
                                  "number-of-bytes", "signed-or-unsigned",
                                  16, ByteCount))
      return nullptr;

    // Checking for signedness.
    if (!RHSList->getChild(1))
      return reportInvalidUse(Loc);
    bool IsSigned = false;
    clang::SourceLocation SignednessLoc = RHSList->getChild(1)->getLocation();
    if (auto SignnessSyntax = dyn_cast<IdentifierSyntax>(RHSList->getChild(1))) {
      if (SignnessSyntax->getSpelling() == "signed") {
        IsSigned = true;
      } else if(SignnessSyntax->getSpelling() == "unsigned") {
        IsSigned = false;
      } else {
        return reportInvalidUse(SignednessLoc, 4);
      }
    } else {
      return reportInvalidUse(SignednessLoc, 4);
    }
    // Now creating the type expression.
    auto Ty = getCxxContext().getIntTypeForBitwidth(8*ByteCount, IsSigned);
    return SemaRef.buildTypeExpr(Ty, Loc);

  } else {
    return reportInvalidUse(Loc);
  }
}

clang::Expr *Elaborator::elaborateCharacterMetaFunction(const BinarySyntax *S) {
  auto LHSSyntax = dyn_cast<LiteralSyntax>(S->getLeftOperand());
  clang::SourceLocation Loc = LHSSyntax->getLocation();
  auto RHSSyntax = S->getRightOperand();
  auto reportInvalidUse = [&](clang::SourceLocation L, int MsgIdx = 0) -> clang::Expr * {
    getCxxSema().Diags.Report(L,
                         clang::diag::err_invalid_use_of_built_in_type_function)
                              << "character" << "number-of-bytes"
                              << "ascii-or-utf"
                              << MsgIdx;
    return nullptr;
  };
  if (auto RHSList = dyn_cast<ListSyntax>(RHSSyntax)) {
    if (RHSList->getNumChildren() != 2)
      return reportInvalidUse(RHSList->getLocation());

    if (!RHSList->getChild(0))
      return reportInvalidUse(Loc);
    int64_t ByteCount = 0;
    if(handleBuiltInByteCountEval(*this, RHSList->getChild(0), "character",
                                  "number-of-bytes", "ascii-or-utf",
                                  4, ByteCount))
      return nullptr;

    // Checking for signedness.
    if (!RHSList->getChild(1))
      return reportInvalidUse(Loc);
    bool IsUTF = false;
    clang::SourceLocation SecondArgLoc = RHSList->getChild(1)->getLocation();
    if (auto SecondArg = dyn_cast<IdentifierSyntax>(RHSList->getChild(1))) {
      if (SecondArg->getSpelling() == "ascii") {
        IsUTF = false;
      } else if(SecondArg->getSpelling() == "utf") {
        IsUTF = true;
      } else {
        return reportInvalidUse(SecondArgLoc, 8);
      }
    } else {
      return reportInvalidUse(SecondArgLoc, 4);
    }
    
    // Now creating the type expression.
    clang::QualType RetTy;
    if(IsUTF) {
      switch(ByteCount) {
      case 1:
        RetTy = getCxxContext().Char8Ty;
        break;
      case 2:
        RetTy = getCxxContext().Char16Ty;
        break;
      case 4:
        RetTy = getCxxContext().Char32Ty;
        break;
      default:
        return reportInvalidUse(SecondArgLoc, 9);
      }
    } else {
      switch(ByteCount) {
      case 1:
        RetTy = getCxxContext().CharTy;
        break;
      default:
        return reportInvalidUse(SecondArgLoc, 8);
      }
    }
    return SemaRef.buildTypeExpr(RetTy, Loc);

  } else {
    return reportInvalidUse(Loc);
  }
}

clang::Expr *Elaborator::elaborateRealMetaFunction(const BinarySyntax *S) {
  auto LHSSyntax = dyn_cast<LiteralSyntax>(S->getLeftOperand());
  clang::SourceLocation Loc = LHSSyntax->getLocation();
  auto RHSSyntax = S->getRightOperand();
  auto reportInvalidUse = [&](clang::SourceLocation L, int MsgIdx =0) -> clang::Expr * {
    getCxxSema().Diags.Report(L,
                         clang::diag::err_invalid_use_of_built_in_type_function)
                              << "real" << "number-of-bytes"
                              << "binary-or-decimal"
                              << MsgIdx;
    return nullptr;
  };
  if (auto RHSList = dyn_cast<ListSyntax>(RHSSyntax)) {
    if (RHSList->getNumChildren() != 2)
      return reportInvalidUse(RHSList->getLocation());

    if (!RHSList->getChild(0))
      return reportInvalidUse(Loc);
    int64_t ByteCount = 0;
    if (handleBuiltInByteCountEval(*this, RHSList->getChild(0), "real",
                                   "number-of-bytes", "binary-or-decimal",
                                   16, ByteCount))
      return nullptr;
    if (ByteCount <= 2)
      return reportInvalidUse(RHSList->getChild(0)->getLocation(), 7);

    // Checking for signedness.
    if (!RHSList->getChild(1))
      return reportInvalidUse(Loc);
    // bool IsSigned = false;
    clang::SourceLocation SignednessLoc = RHSList->getChild(1)->getLocation();
    if (auto SignnessSyntax = dyn_cast<IdentifierSyntax>(RHSList->getChild(1))) {
      if (SignnessSyntax->getSpelling() == "binary") {
        auto Ty = getCxxContext().getRealTypeForBitwidth(8*ByteCount, true);
        return SemaRef.buildTypeExpr(Ty, Loc);
      } else if(SignnessSyntax->getSpelling() == "decimal")
        return reportInvalidUse(SignednessLoc, 6);
      else
        return reportInvalidUse(SignednessLoc, 5);
    } else {
      return reportInvalidUse(SignednessLoc, 4);
    }
  } else {
    return reportInvalidUse(Loc);
  }
}


// Diagnostics
void Elaborator::Error(clang::SourceLocation Loc, llvm::StringRef Msg) {
  CxxSema.Diags.Report(Loc, clang::diag::err_blue_elaboration) << Msg;
}






bool Elaborator::delayElaborateDeclType(clang::CXXRecordDecl *RD,
                                        const Syntax *S) {
  Declaration *D = SemaRef.getCurrentScope()->findDecl(S);
  if (!D) {
    return false;
  }

  // Handling a check for possible late elaboration on each declaration.
  if (phaseOf(D) > Phase::Identification)
    return false;


  // FIXME: This almost certainly needs its own elaboration context
  // because we can end up with recursive elaborations of declarations,
  // possibly having cyclic dependencies.
  // || D->declaresForwardRecordDecl()
  if (D->declaratorContainsTag()) {
    delayElaborationClassBody(D);
    return true;
  }
  bool WasDelayed = false;
  if (D->declaratorContainsFunction()) {
    llvm_unreachable("Member function elaboration not implemented yet");
    // if (D->declIsStatic()) {
    //   // TODO: If this reaches across class then we may need to change how look up
    //   // is handled in this set of circumstances. Because this could
    //   // reach into the scope of another class and get data from there
    //   // but the late elaboration from there might not exist yet.
    //   // So we might need to do partial elaboration of a few things in order to
    //   // correctly define them.
    //   elaborateDecl(D);
    // } else {
    //   if (RD->isUnion()) {
    //     elaborateDecl(D);
    //   } else {
    //     // Attempting to delay method decl/def combos
    //     delayElaborateMethodDecl(D);
    //     WasDelayed = true;
    //   }
    // }
    if (D->hasInitializer()) {
      delayElaborateMethodDef(D);
      WasDelayed = true;
    }
    return WasDelayed;
  }
  elaborateDeclarationTyping(D);
  if (!D->isFieldDecl()) {
    elaborateDefinitionInitialization(D);
    return false;
  }

  if (D->declaresInitializedVariable()) {
    delayElaborateMemberInitializer(D);
    return true;
  }
  return false;
}


void Elaborator::delayElaborateMemberInitializer(Declaration *D) {
  SemaRef.getCurrentElaboratingClass().LateElaborations.push_back(
    new LateElaborateMemberInitializer(SemaRef, D)
  );
}

void Elaborator::delayElaborateMethodDecl(Declaration *D) {
  SemaRef.getCurrentElaboratingClass().LateElaborations.push_back(
    new LateElaboratedMethodDeclaration(SemaRef, D)
  );
}

void Elaborator::delayElaborateMethodDef(Declaration *D) {
  SemaRef.getCurrentElaboratingClass().LateElaborations.push_back(
    new LateElaboratedMethodDef(SemaRef, D)
  );
}

void Elaborator::delayElaborationClassBody(Declaration *D) {
  elaborateDeclarationTyping(D);
}

void Elaborator::delayElaborateDefaultParam(Declaration *ParamDecl) {
  assert(SemaRef.CurrentLateMethodDecl && "Late method decl not set");
  SemaRef.CurrentLateMethodDecl->DefaultArgs.emplace_back(ParamDecl);
}



void Elaborator::finishDelayedElaboration(ElaboratingClass &Class) {
  lateElaborateAttributes(Class);
  lateElaborateMethodDecls(Class);
  lateElaborateDefaultParams(Class);
  // We call this because no new declarations can be added after this point.
  // This is only called for the top level class.
  SemaRef.getCxxSema().ActOnFinishCXXMemberDecls();

  lateElaborateMemberInitializers(Class);
  lateElaborateMethodDefs(Class);
}

void Elaborator::lateElaborateAttributes(ElaboratingClass &Class) {
  bool CurrentlyNested = !Class.IsTopLevelClass;
  Sema::ClangScopeRAII AttributeDelayedScope(SemaRef, clang::Scope::DeclScope |
    clang::Scope::ClassScope, clang::SourceLocation(), CurrentlyNested);


  OptionalInitScope<ResumeScopeRAII> OptResumeScope(SemaRef);

  // This may need to be moved to somewhere else.
  if (CurrentlyNested) {
    OptResumeScope.Init(Class.TagOrTemplate->SavedScope,
                        Class.TagOrTemplate->Def);
    SemaRef.getCxxSema().ActOnStartDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());
  }

  for (size_t i = 0; i < Class.LateElaborations.size(); ++i) {
    Class.LateElaborations[i]->ElaborateAttributes();
  }
  if (CurrentlyNested)
    SemaRef.getCxxSema().ActOnFinishDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());
}

void Elaborator::lateElaborateMethodDecls(ElaboratingClass &Class) {
  // If the current class is a template re-enter the template before we continue.
  bool HasTemplateScope = !Class.IsTopLevelClass && Class.TemplateScope;
  Sema::ClangScopeRAII ClassTemplateScope(SemaRef,
    clang::Scope::TemplateParamScope, clang::SourceLocation(), HasTemplateScope);

  if (HasTemplateScope)
    SemaRef.getCxxSema().ActOnReenterTemplateScope(Class.TagOrTemplate->getCxx(),
                                                   [&] {
      return SemaRef.getCurClangScope();
    });

  bool CurrentlyNested = !Class.IsTopLevelClass;
  Sema::ClangScopeRAII FunctionDeclScope(SemaRef, clang::Scope::DeclScope |
    clang::Scope::ClassScope, clang::SourceLocation(), CurrentlyNested);

  OptionalInitScope<Sema::DeclContextRAII> DCTracking(SemaRef);
  OptionalInitScope<ResumeScopeRAII> OptResumeScope(SemaRef);

  // This may need to be moved to somewhere else.
  if (CurrentlyNested) {
    OptResumeScope.Init(Class.TagOrTemplate->SavedScope,
      Class.TagOrTemplate->Def, false);
    SemaRef.getCxxSema().ActOnStartDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());
    DCTracking.Init(Class.TagOrTemplate, true);
  }

  for (size_t i = 0; i < Class.LateElaborations.size(); ++i) {
    Class.LateElaborations[i]->ElaborateMethodDeclarations();
  }

  if (CurrentlyNested)
    SemaRef.getCxxSema().ActOnFinishDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());
}

void Elaborator::lateElaborateDefaultParams(ElaboratingClass &Class) {
  for (size_t i = 0; i < Class.LateElaborations.size(); ++i) {
    Class.LateElaborations[i]->ElaborateDefaultParams();
  }
}

void Elaborator::lateElaborateMemberInitializers(ElaboratingClass &Class) {
  bool CurrentlyNested = !Class.IsTopLevelClass;

  Sema::ClangScopeRAII MemberInitScope(SemaRef, clang::Scope::DeclScope |
    clang::Scope::ClassScope, clang::SourceLocation(), CurrentlyNested);

  OptionalInitScope<ResumeScopeRAII> OptResumeScope(SemaRef);
  OptionalInitScope<Sema::DeclContextRAII> DCTracking(SemaRef);

  // This may need to be moved to somewhere else.
  if (CurrentlyNested) {
    OptResumeScope.Init(Class.TagOrTemplate->SavedScope,
      Class.TagOrTemplate->Def, false);
    SemaRef.getCxxSema().ActOnStartDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());
    DCTracking.Init(Class.TagOrTemplate, true);
  }

  clang::Sema::CXXThisScopeRAII PushThisIntoScope(SemaRef.getCxxSema(),
      Class.TagOrTemplate->getCxx(), clang::Qualifiers());

  for (size_t i = 0; i < Class.LateElaborations.size(); ++i) {
    Class.LateElaborations[i]->ElaborateMemberInitializers();
  }

  if (CurrentlyNested)
    SemaRef.getCxxSema().ActOnFinishDelayedMemberDeclarations(
      SemaRef.getCurClangScope(), Class.TagOrTemplate->getCxx());

  SemaRef.getCxxSema().ActOnFinishDelayedMemberInitializers(
    Class.TagOrTemplate->getCxx());
}

void Elaborator::lateElaborateMethodDefs(ElaboratingClass &Class) {
  bool CurrentlyNested = !Class.IsTopLevelClass;
  Sema::ClangScopeRAII MethodDefScope(SemaRef, clang::Scope::DeclScope |
    clang::Scope::ClassScope, clang::SourceLocation(), CurrentlyNested);

  OptionalInitScope<ResumeScopeRAII> OptResumeScope(SemaRef);

  // This may need to be moved to somewhere else.
  if (CurrentlyNested)
    OptResumeScope.Init(Class.TagOrTemplate->SavedScope,
      Class.TagOrTemplate->Def, false);

  for (size_t i = 0; i < Class.LateElaborations.size(); ++i) {
    Class.LateElaborations[i]->ElaborateMethodDefs();
  }
}

void Elaborator::lateElaborateAttribute(LateElaboratedAttributeDecl &Field) {
  // TODO: find a valid example of how this actually works/when this is used.
  llvm_unreachable("We currently don't have late binding attributes? I don't "
      "really know.");
}

void Elaborator::lateElaborateMethodDef(LateElaboratedMethodDef &Method) {
  // if (!Method.D->Cxx)
  //   return;
  // // Finish exception spec before method body?
  // {
  //   if (!Method.D->FunctionDcl)
  //     return;
  //   FunctionDeclarator *FnDecl = Method.D->FunctionDcl->getAsFunction();
  //   // Attempting to push the scope for the current function onto the stack
  //   // This helps with lookup during evaluation exception specification.
  //   ResumeScopeRAII TempScope(SemaRef,
  //                                   FnDecl->getScope(),
  //                                   FnDecl->getScope()->getConcreteTerm(),
  //                                   /*PopOnExit=*/false);
  //   OptionalInitClangRAII<clang::Sema::CXXThisScopeRAII> ThisScope(
  //                                                                      SemaRef);
  //   if (clang::CXXMethodDecl *MD
  //                             = dyn_cast<clang::CXXMethodDecl>(Method.D->Cxx)) {
  //     ThisScope.Init(MD->getParent(), MD->getMethodQualifiers(), true);
  //   }
  //   finishExceptionSpecAttr(Context, SemaRef, Method.D);
  // }
  // elaborateFunctionDef(Method.D);
  // if (!Method.D->Cxx)
  //   return;
  // SemaRef.getCxxSema().ActOnFinishInlineFunctionDef(
  //   cast<clang::FunctionDecl>(Method.D->Cxx));
  llvm_unreachable("Late elaborate method def not implemented yet.");
}


void Elaborator::lateElaborateMemberInitializer(
    LateElaborateMemberInitializer &MemberInit) {
  assert(MemberInit.D && "Invalid declaration detected.");
  assert(MemberInit.D->isFieldDecl()
         && "Declaration doesn't declare a field.\n");

  // Start delayed member This occurs for each member initializer within a
  // given class.
  elaborateDefinitionInitialization(MemberInit.D);
}

void Elaborator::lateElaborateMethodDecl(
    LateElaboratedMethodDeclaration &Method) {
  // Sema::ClangScopeRAII FunctionDeclScope(SemaRef, clang::Scope::DeclScope |
  //     clang::Scope::FunctionPrototypeScope |
  //     clang::Scope::FunctionDeclarationScope,
  //     clang::SourceLocation());
  // Sema::LateMethodRAII MethodTracking(SemaRef, &Method);
  // elaborateDecl(Method.D);
  // // This is to check if the method delcaration was a success and in the event
  // // that it is we need to finish the exception specifier after the end of the
  // // class.
  // if (Method.D->Cxx) {
  //   if (clang::FunctionDecl *FD = dyn_cast<clang::FunctionDecl>(Method.D->Cxx)) {
  //     if (FD->getExceptionSpecType() == clang::EST_Unparsed) {
  //       if (!Method.D->Init) {
  //         SemaRef.getCurrentElaboratingClass().LateElaborations.push_back(
  //           new LateElaboratedMethodDef(SemaRef, Context, Method.D)
  //         );
  //       }
  //     }
  //   }
  // }
  // SemaRef.getCxxSema().ActOnFinishDelayedCXXMethodDeclaration(
  //     SemaRef.getCurClangScope(), Method.D->Cxx);
  llvm_unreachable("Late method declaration not implemented yet.");
}

void Elaborator::lateElaborateDefaultParams(
    LateElaboratedMethodDeclaration &MethodDecl) {
  for(LateElaboratedDefaultArgument &Arg : MethodDecl.DefaultArgs)
    lateElaborateDefaultParam(Arg);
}

void Elaborator::lateElaborateDefaultParam(
    LateElaboratedDefaultArgument &DefaultParam) {
  elaborateDefinitionInitialization(DefaultParam.Param);
}

} // namespace blue
